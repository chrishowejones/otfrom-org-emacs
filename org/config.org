* Helpers

  There are a number of helper functions that we'll need through the
  rest of this. We'll just define them up here.

** load-if-exists

   This is just a nice function to load a file if it exists, but just
   print a message rather than an error if it doesn't. This is handy
   for things like loading specific local config that you don't want
   to go into github or be shared such as erc nicks, passwords, blog
   rolls, etc.

   #+BEGIN_SRC emacs-lisp
     (defun load-if-exists (file)
       (if (file-exists-p file)
           (progn
             (load file)
             (message (format "Loading file: %s" file)))
         (message (format "No %s file. So not loading one." file))))
   #+END_SRC

** Install Try

   Saw this in C'est la Z's youtube videos as a way to try out emacs
   packages without installing them.

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'try)
   #+END_SRC

** Install straight package mgr

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (setq package-enable-at-startup nil)
#+end_src

* Globals

** Set initial framesize

   #+BEGIN_SRC emacs-lisp
     (setq initial-frame-alist '((top . 0) (left . 0) (width . 140)
     (height . 45)))
   #+END_SRC

** Which browser

   Things in browse-url land seem a bit flaky atm.

   #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'browse-url-generic
           browse-url-generic-program "google-chrome")
   #+END_SRC

** Undo tree

   Add undo tree for the few times I get confused about where I am in
   the undo cycle.

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'undo-tree)
    (undo-tree-mode 1)
   #+END_SRC

** Auto indent on newline

   Again something lifted from
   www.masteringemacs.org/article/beginners-guide-to-emacs

   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "RET") 'newline-and-indent)
   #+END_SRC

** Next line add newlines

   Add new lines at end of buffer when navigating to next line.

   #+BEGIN_SRC emacs-lisp
     (setq next-line-add-newlines t)
   #+END_SRC
** upcase and downcase region

   I like to be able to do this. I get lots of things that come in
   SHOUTING or that need to SHOUT.

   #+BEGIN_SRC emacs-lisp
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC

** Narrowing the region to what I want to look at

   This isn't needed quite so much now that searches, regexp and
   otherwise operate, sometimes annoyingly to an old timer like me, on
   the region rather than the whole buffer window. I still like to
   narrow down to what I'm interested in though and not every handy
   tool in emacs is quite so region oriented.

   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC

** diminish

   As we add lots of useful minor-modes the mode line can get a bit
   unwieldy. diminish-mode helps us with that. We'll set it up here
   and use it in various places throughout the setup.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'diminish)
   #+END_SRC

** Tabs are Evil

   I mean, not like evil-mode is good for vi users who want to use
   emacs, which is fine, and obviously not like a truly evil thing,
   but you know, not what I want. Hey, I can use hyperbole in my
   org-mode files if I want to.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** uniquify

   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'post-forward)
   #+END_SRC

** Multiple Cursors

   This is a replacement for the iedit that I used to have. Neale
   Swinnerton was the one who showed this to me and it looked really
   cool.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'multiple-cursors)
     (multiple-cursors-mode 1)
     (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
     (global-set-key (kbd "C->") 'mc/mark-next-like-this)
     (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
     (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
   #+END_SRC

** Make emacs Discoverable

   I started following [[https://twitter.com/melpa_emacs][@melpa_emacs]] at the end of 2013. From that I
   discovered (see what I did there) discover.el, which has an
   explanatory blog post [[http://www.masteringemacs.org/articles/2013/12/21/discoverel-discover-emacs-context-menus/][here]].


   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'makey)
     (maybe-install-and-require 'discover)
     (global-discover-mode 1)
   #+END_SRC

** What do I use

   Profile your usage.
   Find out what you use the most
   by using keyfreq.

   - [[http://twitter.com/EmacsHaiku/status/443757260682956800][@EmacsHaiku]]

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'keyfreq)
     (keyfreq-mode 1)
     (keyfreq-autosave-mode 1)
   #+END_SRC

** Add /usr/bin to path

   #+BEGIN_SRC emacs-lisp
     (setq exec-path (append exec-path '("/usr/bin")))
   #+END_SRC

** Add exec path from shell

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'exec-path-from-shell)
    (exec-path-from-shell-initialize)
   #+END_SRC

** iy-go-to-char

   Saw this on magnars episode 4 of emacs rocks

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'iy-go-to-char)
     (global-set-key (kbd "M-m") 'iy-go-to-char)
   #+END_SRC

** Remap M-i to back-to-indentation

   I am using M-m to iy-go-to-char so I'm remapping
   back-to-indentation to M-i

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-i") 'back-to-indentation)
   #+END_SRC

** loccur mode

   loccur mode hides all lines except those containing matches

   #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'loccur)
      (global-set-key (kbd "C-M-o") 'loccur-current)
      (global-set-key (kbd "C-M-S-o") 'loccur)
   #+END_SRC

** Tooltips in echo area

   Got this from www.masteringemacs.org

   #+BEGIN_SRC emacs-lisp
     (tooltip-mode -1)
     (setq tooltip-use-echo-area nil)
   #+END_SRC

** Y and N prompts

   Change the yes and no prompts to y and n

   #+BEGIN_SRC emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Time in status

   #+BEGIN_SRC emacs-lisp
    (display-time-mode 1)
   #+END_SRC

** Set fundamental mode for large files

   Performance for loading large files with font lock etc. on is poor
   so make buffer fundamental and read only for large files.

   #+BEGIN_SRC emacs-lisp
     (defun my-find-file-check-make-large-file-read-only-hook ()
       "If a file is over a given size, make the buffer read only."
       (when (> (buffer-size) (* 1024 1024))
         (setq buffer-read-only t)
         (buffer-disable-undo)
         (fundamental-mode)))
     (add-hook 'find-file-hook 'my-find-file-check-make-large-file-read-only-hook)
     (add-hook 'helm-find-files-hook 'my-find-file-check-make-large-file-read-only-hook)
   #+END_SRC

** Key chord mode

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'key-chord)
    (setq key-chord-two-keys-delay 0.1)
    (setq key-chord-one-key-delay 0.2)
    (key-chord-mode 1)
   #+END_SRC

** Use hide show minor mode everywhere

   #+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook 'hs-minor-mode)
   #+END_SRC

** require final newline

   #+BEGIN_SRC emacs-lisp
    (setq require-final-newline nil)
   #+END_SRC

** Load prefer newer

   #+BEGIN_SRC emacs-lisp
    (setq load-prefer-newer t)
   #+END_SRC

** Enable eldoc in minibuffer

   #+BEGIN_SRC emacs-lisp
    (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode)
   #+END_SRC

** Disable bell

   #+BEGIN_SRC emacs-lisp
    (setq ring-bell-function 'ignore)
   #+END_SRC

** Remap transpose sexps

   Remap transpose sexps as gnome is using C-M-t for terminal

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-M-S-T") 'transpose-sexps)
   #+END_SRC

** Mute dialog for safe variables list

   Add to safe variables list to mute messages from .dir-locals

   #+BEGIN_SRC emacs-lisp
    (defun hack-local-variables-confirm (f &rest args)
    "Disables annoying dialog 'The local variables list in :x contains values that may not be safe"
    t)
   #+END_SRC

* non-elpa and work arounds

  At the moment we don't have any workarounds. It looked like we might
  need one for cider for a while but the marvelously helpful grand
  master of the [[https://github.com/clojure-emacs][clojure Emacs repo]] [[http://twitter.com/bbatsov][Bozhidar Batsov]] has fixed it.

** non-elpa files

   Unfortunately, we can't get everything we want from the package
   archives or we might have files that we're working on locally that
   we haven't released yet. We keep those in a non-elpa directory. We
   need to add this to the load-path so that we can require the files
   we have here.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat user-emacs-directory "non-elpa/"))
   #+END_SRC

* Macintosh Specific Setup

** # is broken on UK Macs

   On UK keyboards shift-3 is bound to £. This is a real pain. The #
   character is usually bound to M-3. This also causes problems,
   especially with things like window-number modes. We have a hacked
   window-number mode below that maps window 3 to s-3, which solves
   that problem. The # problem is solved with this bit of code below.

   #+BEGIN_SRC emacs-lisp
     ;; (when (memq window-system '(mac ns))
     ;;   (global-set-key (kbd "M-3") '(lambda () (interactive) (insert "#"))))
   #+END_SRC

   We also need to deal with £ being a UTF-8 character so we don't get
   annoying Â characters before non-ascii characters.

   #+BEGIN_SRC emacs-lisp
     (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
   #+END_SRC

** window-number-super mode

   On a mac we have M-3 mapped to be the #

   #+BEGIN_SRC emacs-lisp
       (progn
         (maybe-install-and-require 'window-number)
         (window-number-mode 1)
         (window-number-meta-mode 1))
   #+END_SRC

** $PATH is broken

   If you don't run emacs in a terminal on Mac OS X then it can be
   really awkward to get the stuff you want in your path. This is the
   best way I've found so far to sort this out and get things like
   ~/bin and /usr/loca/bin in a $PATH that emacs can access. I quite
   like running emacs from outside the terminal.

   Thanks to the lovely and helpful [[https://twitter.com/_tobrien][Tom O'Brien]] I've got a better way
   of doing this and now my emacs environment will be in sync with my
   shell. You can out more at the github page for
   [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]].

   #+BEGIN_SRC emacs-lisp
     (when (memq window-system '(mac ns))
       (progn
         (maybe-install-and-require 'exec-path-from-shell)
         (exec-path-from-shell-initialize)))
   #+END_SRC

** ns-win keys that I want to die

   There are a number of Mac/Next things in ns-win.el that are
   supposed to be there to make things friendlier for people who are
   interface damaged by Mac OS X and similar. I'm damaged by other
   things and hope to be moving back to a Linux flavour of some sort
   again soon.

*** ns-do-hide-emacs

    This is the keybinding that is annoying me the most atm. I'd quite
    like it to work for headlines in helm in most programming modes
    instead.

    #+BEGIN_SRC emacs-lisp
      (when (memq window-system '(mac ns))
        (global-unset-key (kbd "s-h")))
    #+END_SRC

** command key as meta

   #+BEGIN_SRC emacs-lisp
    (setq mac-command-modifier 'super)
    (setq mac-option-modifier 'meta)
   #+END_SRC

* Make it Pretty

** color themes

*** custom-theme-directory

    Themes seem to be quite picky about where they live. They require
    custom-theme-directory to be set. By default this is the same as
    user-emacs-directory, which is usually ~/.emacs.d. I'd like to
    keep them separate if possible. I learned this one by reading
    some of [[https://github.com/sw1nn/dotfiles][Neale Swinnerton's dotfiles]].

    #+BEGIN_SRC emacs-lisp
      (setq custom-theme-directory (concat user-emacs-directory "themes"))
    #+END_SRC


*** leuven

    Whiteboard theme.

    #+BEGIN_SRC emacs-lisp
      ;; (load-theme 'whiteboard)
    #+END_SRC
*** noctilux

    [[http://www.lighttable.com/][LightTable]] is awfully pretty. And now that it is GPL I might even
    use it (please don't tell emacs).

    #+BEGIN_SRC emacs-lisp
;;     (maybe-install-and-require 'noctilux-theme)
    #+END_SRC

*** monokai

    Saw this in someone's blog and thought I'd give it a looksie

    #+BEGIN_SRC emacs-lisp
;;      (maybe-install-and-require 'monokai-theme)
    #+END_SRC

*** grandshell

    I've been finding lots of interesting things from [[https://twitter.com/steckerhalter][steckerhalter]]
    and this [[https://github.com/steckerhalter/grandshell-theme][grandshell]] theme looks pretty good. I'm going to try it
    for a while.

    #+BEGIN_SRC emacs-lisp
;;      (maybe-install-and-require 'grandshell-theme)
    #+END_SRC

*** cyberpunk, I still love you

    I really like the cyberpunk theme from [[https://github.com/overtone/emacs-live][emacs-live]] and [[https://twitter.com/samaaron][Sam Aaron]] is
    a lovely guy. I wanted to avoid needing the old color-theme
    mode. [[https://twitter.com/rikardglans][Rikard Glans]] was nice enought to port it over to the new
    stuff.

    I'm not using it at the moment as I'm trying out other themes.

    #+BEGIN_SRC emacs-lisp
;;       (maybe-install-and-require 'cyberpunk-theme)
    #+END_SRC

*** flatland, I am learning to love you

    #+BEGIN_SRC emacs-lisp
;;       (load-theme 'flatland)
    #+END_SRC

*** solarized

    Solarized looks quite cool. Using the port from [[https://github.com/sellout][Greg Pfeil]].

    #+BEGIN_SRC emacs-lisp
;;       (maybe-install-and-require 'solarizeda-theme)
    #+END_SRC

*** Flatland Black theme

    Flatland lack cos I prefer the higher contrast than flatland

    #+BEGIN_SRC emacs-lisp
;;      (maybe-install-and-require 'flatland-black-theme)
    #+END_SRC
*** Nimbus theme

    #+BEGIN_SRC emacs-lisp

;;     (maybe-install-and-require 'nimbus-theme)
;;     (load-theme 'nimbus)
    #+END_SRC

*** Github theme

    #+BEGIN_SRC emacs-lisp
;;     (maybe-install-and-require 'github-theme)
    #+END_SRC

*** FlatUI Theme

    Looks like a decent light theme.

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'flatui-theme)
    #+END_SRC

*** Gruvbox theme

    #+BEGIN_SRC emacs-lisp
;;     (maybe-install-and-require 'gruvbox-theme)
    #+END_SRC

** fonts

   Using init-fonts to globally change font sizes.

   #+BEGIN_SRC emacs-lisp
     (require 'init-fonts)
   #+END_SRC

*** Default font height

    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'default nil :height 80)
    #+END_SRC


*** Default font scale

    #+BEGIN_SRC emacs-lisp
      (require 'default-text-scale)
      (setq default-text-scale-mode t)
    #+END_SRC

** bars, menus and numbers

   I like no scroll bars, no toolbars and line and column numbers in
   the mode-line.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     (line-number-mode -1)
     (column-number-mode 1)
     (menu-bar-mode -1)
     (setq display-line-numbers-type 'absolute)
     (global-display-line-numbers-mode)
   #+END_SRC

** Startup Screen

   I'd also like to ski the startup screen and go straight to
   the *dashboard* buffer.

   #+BEGIN_SRC emacs-lisp
     (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
     ;;(setq inhibit-startup-screen t)
   #+END_SRC

** alpha alpha alpha

   I don't use this all the time, but sometimes, when I'm hacking
   only on my diddy 13" laptop I like to have a window tailing a file
   in the background while I'm writing something in the
   foreground. This let's us toggle transparency. Who wouldn't like
   that? I'm pretty sure I got this from [[https://twitter.com/IORayne][Anthony Grimes]].

   #+BEGIN_SRC emacs-lisp
     (defun toggle-transparency ()
       (interactive)
       (let ((param (cadr (frame-parameter nil 'alpha))))
         (if (and param (/= param 100))
             (set-frame-parameter nil 'alpha '(100 100))
           (set-frame-parameter nil 'alpha '(50 50)))))
     (global-set-key (kbd "C-c t") 'toggle-transparency)
   #+END_SRC

** Golden ratio

   I quite liked this when I spotted it in spacemacs. Couldn't get on
   with spacemacs itself but I'm stealing the best bits.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'golden-ratio)
     ;;(golden-ratio-mode 1)
   #+END_SRC

** emojis

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'emojify)
     ;; (add-hook 'after-init-hook #'global-emojify-mode)
   #+END_SRC

** All the icons

   #+BEGIN_SRC emacs-lisp
   (when (display-graphic-p)
    (require 'all-the-icons))
   #+END_SRC

** Beacon

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'beacon)
     (beacon-mode 1)
   #+END_SRC

* Tool Configuration

** ediff

   ediff is my favourite way of comparing files, directories, versions
   and buffers in emacs. It does annoy me the way it brings up a new
   frame though. I'd much rather keep everything in the same frame
   even when I'm on a windowing system.

   #+BEGIN_SRC emacs-lisp
     (setq ediff-window-setup-function 'ediff-setup-windows-plain)
   #+END_SRC

** company

   Complete Anything or [[http://company-mode.github.io/][company-mode]] seems to be the way to complete
   things in emacs now.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'company)
     (add-hook 'after-init-hook 'global-company-mode)
     (diminish 'company-mode "CA")
     (global-set-key (kbd "M-TAB") 'company-complete)
   #+END_SRC

*** Company-quickhelp

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'company-quickhelp)
      (company-quickhelp-mode)
    #+END_SRC

** Base64 (add prefix command)

   #+BEGIN_SRC emacs-lisp
    (defun base64-encode-region-prefix-arg (&rest _args)
      "Pass prefix arg as third arg to `base64-encode-region'."
      (interactive "r\nP"))
    (advice-add 'base64-encode-region :before #'base64-encode-region-prefix-arg)
   #+END_SRC

** Restart emacs

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'restart-emacs)
   #+END_SRC
* directories, navigation, searching, movement
** dired

   dired can do lots of things. I'm pretty basic in my use. I do like
   to have the file listings use human friendly numbers though.

   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-alh")
   #+END_SRC

** dirtree

   Going to try out dirtree

   #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'dirtree)
   #+END_SRC

** Treemacs

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'treemacs)
     (use-package treemacs-magit
       :after treemacs magit
       :ensure t)
     (use-package treemacs-projectile
       :after treemacs projectile
       :ensure t)

     (use-package treemacs-icons-dired
       :after treemacs dired
       :ensure t
       :config (treemacs-icons-dired-mode))
   #+END_SRC



** helm-mode

   helm-mode is the succesor to anything.el. I don't really have my
   head around it all yet, but I'm already pretty impressed with it so
   I'll include it here and add more to it as I understand what is
   going on.

   My helm-mode guru is [[http://twitter.com/krisajenkins][Kris Jenkins]].

   #+BEGIN_SRC emacs-lisp
     ;;(maybe-install-and-require 'helm)
     (use-package helm
       :straight t)
     (global-set-key (kbd "M-x") #'helm-M-x)
     (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
     (global-set-key (kbd "C-x C-f") #'helm-find-files)
     (global-set-key (kbd "s-i") #'helm-semantic-or-imenu)
     (global-set-key (kbd "C-x C-M-o") #'helm-occur)
     (global-set-key (kbd "C-x c C-b") #'helm-mini)
   #+END_SRC

** ido

*** ido fix mode

    Seen this recommended by Bug in Projectile docs and anything good
    enough for him is good enough for me.

    #+BEGIN_SRC
      (maybe-install-and-require 'fix-ido)
    #+END_SRC

*** ido flex matching

    Anything that lets me type less to get to where I want to be is
    what I'm after.

    #+BEGIN_SRC emacs-lisp
;;      (setq ido-enable-flex-matching 1)
    #+END_SRC

*** ido use filename at point

    I like having ffap be a default.

    #+BEGIN_SRC emacs-lisp
      ;; (setq ido-use-filename-at-point 'guess)
    #+END_SRC

** git

*** magit

    magit is a *fantastic* mode for dealing with git.

    #+BEGIN_SRC emacs-lisp
       (maybe-install-and-require 'magit)
    #+END_SRC

    I use magit-status a lot. So let's bind it to C-x g.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-x g") 'magit-status)
    #+END_SRC

*** magit todos

    magit todos

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'magit-todos)
    #+END_SRC

*** git-gutter-mode+

    It is really nice having +/= in the gutter. I like it more than
    having line numbers and thus I've dumped linum-mode.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'git-gutter-fringe+)
      (global-git-gutter+-mode t)
    #+END_SRC

    It is also quite nice to be able to navigate a file by he git
    hunks. It makes it a bit easier to see what has changed since the
    last time in the context of the whole file.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-n") 'git-gutter+-next-hunk)
      (global-set-key (kbd "s-p") 'git-gutter+-previous-hunk)
    #+END_SRC

    We can diminish the size of GitGutter in the mode-line

    #+BEGIN_SRC emacs-lisp
      (diminish 'git-gutter+-mode)
    #+END_SRC

*** git-messenger

    Get the commit information for the current line. A bit like a mini
    git blame.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'git-messenger)
    #+END_SRC

*** github-browse-file

    When working with others I often want to point out a line I'm
    looking at in a file we already have in github. I'd like to be
    able to get the link rather than doing some sort of
    paste/gist/refheap.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'github-browse-file)
    #+END_SRC

*** forge

    #+BEGIN_SRC emacs-lisp
      ;; (with-eval-after-load 'magit
      ;;  (require 'forge))
    #+END_SRC

*** gitlink

    #+begin_src emacs-lisp
     (maybe-install-and-require 'git-link)
     (global-set-key (kbd "C-c g l") 'git-link)
     (setq git-link-open-in-browser t)
    #+end_src

** avy-mode

   This is supposed to be a replacement for ace-jump-mode so thought
   I'd give it a whirl.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'avy)
     (avy-setup-default)
     (global-set-key (kbd "C-c j") 'avy-goto-word-or-subword-1)
     (global-set-key (kbd "M-g g") 'avy-goto-line)
     (global-set-key (kbd "C-c k") 'avy-kill-region)
     (global-set-key (kbd "C-c w") 'avy-goto-char-timer)
     (global-set-key (kbd "C-c c") 'avy-goto-char)
   #+END_SRC
** Registers

   #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c r SPC") 'point-to-register)
    (global-set-key (kbd "C-c r j") 'jump-to-register)
   #+END_SRC

** dumb-jump-mode

   Jump to definitions. I know imenu can do this too but let's give it
   a try.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'dumb-jump)
     (global-set-key (kbd "C-s-g") 'dumb-jump-go)
     (global-set-key (kbd "C-s-p") 'dumb-jump-back)
     (global-set-key (kbd "C-s-q") 'dumb-jump-quick-look)
   #+END_SRC

** Mouse Avoidance

   I don't want that pesky mouse hanging around in the middle of the
   screen while I'm typing.

   #+BEGIN_SRC emacs-lisp
     (mouse-avoidance-mode 'banish)
   #+END_SRC

** window and buffer tweaking

*** window movement
l
    I need to remap the windmove keys so that they don't conflict with
    the org-mode or paredit keys.

    #+BEGIN_SRC emacs-lisp
      (global-set-key [M-s-up] 'windmove-up)
      (global-set-key [M-s-down] 'windmove-down)
      (global-set-key [M-s-right] 'windmove-right)
      (global-set-key [M-s-left] 'windmove-left)
    #+END_SRC

*** buffer movement

    Sometimes the problem isn't that you want to move the cursor to a
    particular window, but you want to move a buffer. buffer-move lets
    you do that.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'buffer-move)
      (global-set-key (kbd "<s-up>")     'buf-move-up)
      (global-set-key (kbd "<s-down>")   'buf-move-down)
      (global-set-key (kbd "<s-left>")   'buf-move-left)
      (global-set-key (kbd "<s-right>")  'buf-move-right)
    #+END_SRC

*** shrink and enlarge windows

    On large screens where there are lots of windows in a frame we'll
    often want to shrink or grow individual windows. It would be handy
    to have easier keys for this.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "s-=") 'shrink-window)
      (global-set-key (kbd "s-+") 'enlarge-window)
    #+END_SRC
*** fullscreen

    Want to toggle fullscreen on a keybinding M-f9

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "<M-f9>") 'toggle-frame-fullscreen)
    #+END_SRC
*** maximise frame

    Want to toggle maximize frame on a keybinding M-f10

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "<M-f10>") 'toggle-frame-maximized)
    #+END_SRC
** backup directories

   I'm fed up of having to put *~ into my .gitignore everywhere and
   I shouldn't really leave emacs only things in there anyway. Let's
   just move all the backup files to one directory.

   #+BEGIN_SRC emacs-lisp
     (setq
      backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
      auto-save-file-name-transforms
      '((".*" "~/.saves"))
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      version-control t)       ; use versioned backups
   #+END_SRC

** ibuffer

   I've never used ibuffer much before, but many people swear by it
   (rather than at it). I've tried it now and it looks good. So let's
   rebind C-x C-b.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x C-b") 'ibuffer)
   #+END_SRC

** projectile

   [[https://github.com/bbatsov/projectile][projectile]] from [[http://twtitter.com/bbatsov][Bozhidar Batsov]] constrains and helps things like
   searches so that they happen within a git repo or leiningen
   project.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'projectile)
     (projectile-global-mode)
     (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
   #+END_SRC

   But we don't need to see that projectile mode is running everywhere
   so let's diminish it.

   #+BEGIN_SRC emacs-lisp
     (diminish 'projectile-mode)
   #+END_SRC

   Configure a gradlew project type to find test files on assumption
   it's a Java project.

   #+BEGIN_SRC emacs-lisp
    (projectile-register-project-type 'gradlew '("gradlew")
                                  :project-file "gradlew"
				  :compile "./gradlew build"
				  :test "./gradlew clean test"
				  :test-suffix "Test")
   #+END_SRC

*** projectile and helm

    Of course projectile and helm play along nicely. This is a
    replacement for the super-t stuff I had before.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'helm-projectile)
      (helm-projectile-on)
    #+END_SRC

*** projectile indexing

    Set alien indexing for projectile

    #+BEGIN_SRC emacs-lisp
      (setq projectile-indexing-method 'alien)
    #+END_SRC

*** close all buffers that don't belong to a projectile project

    #+BEGIN_SRC emacs-lisp
      (defun modi/kill-non-project-buffers (&optional kill-special)
        "Kill buffers that do not belong to a `projectile' project.

      With prefix argument (`C-u'), also kill the special buffers."
        (interactive "P")
        (let ((bufs (buffer-list (selected-frame))))
          (dolist (buf bufs)
            (with-current-buffer buf
              (let ((buf-name (buffer-name buf)))
                (when (or (null (projectile-project-p))
                          (and kill-special
                               (string-match "^\*" buf-name)))
                  ;; Preserve buffers with names starting with *scratch or *Messages
                  (unless (string-match "^\\*\\(\\scratch\\|Messages\\|dashboard\\)" buf-name)
                    (message "Killing buffer %s" buf-name)
                    (kill-buffer buf))))))))
    #+END_SRC

** Ag, the silver searcher with helm

   This is basically:

   find . -type f | xargs grep -in <sommat>

   but faster and with helm-y goodness. Put in a pattern and then use
   helm to narrow it down.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'helm-ag)
   #+END_SRC

** Winnow

   Use winnow to filter results of compilation buffers but
   particularly with ag

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'winnow)
     (add-hook 'ag-mode-hook 'winnow-mode)
     (add-hook 'compilation-mode-hook 'winnow-mode)
   #+END_SRC

** guide key

   I want to try out guide key as it looks cool and I'm terrible for
   remembering keybindings (sign of getting old)

   #+BEGIN_SRC emacs-lisp
     ;; (maybe-install-and-require 'guide-key)
     ;; (setq guide-key/guide-key-sequence t)
     ;; (setq guide-key/recursive-key-sequence-flag t)
     ;; (setq guide-key/idle-delay 1)
     ;; (setq guide-key/popup-window-position :bottom)
     ;; (guide-key-mode 1)
   #+END_SRC

** Which key

   Try which key instead of guide key

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'which-key)
    (which-key-mode)
   #+END_SRC

** expand region

   Use expand region to widen marked text

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'expand-region)
     (global-set-key (kbd "C-=") 'er/expand-region)
   #+END_SRC

** Jump to top or bottom of window

   Set up move-to-window-line 0 and move-to-window-line -

   #+BEGIN_SRC emacs-lisp
     (defun top-of-window ()
       (interactive)
       (move-to-window-line 0))
     (global-set-key (kbd "C-s-h") 'top-of-window)
     (defun bottom-of-window ()
       (interactive)
       (move-to-window-line -1))
     (global-set-key (kbd "C-s-l") 'bottom-of-window)
   #+END_SRC

** Imenu

   Using imenu to navigate to a symbol

   #+BEGIN_SRC emacs-lisp
;;     (global-set-key (kbd "s-i") 'imenu)
   #+END_SRC


*** github-review

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'github-review)
    #+END_SRC

** Swiper-Helm

   I'm going to use Swiper Helm for search for a bit but I'm not sure
   about suing ivy-mode completion and counsel as I'm kind of
   comfortable with helm and company-mode for now.

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'swiper-helm)
    (global-set-key (kbd "C-s") 'swiper)
   #+END_SRC

** recentf mode

   Switch on recentf-mode

   #+BEGIN_SRC emacs-lisp
     (setq recentf-auto-cleanup 'never) ;; disable before we start recentf!
     (recentf-mode 1)
     (setq recentf-max-menu-items 25)
     (setq recentf-max-saved-items 25)
     (global-set-key "\C-x\ \C-r" 'recentf-open-files)
   #+END_SRC

** hydra

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'hydra)
   #+END_SRC

** Dashboard

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'dashboard)
     (dashboard-setup-startup-hook)
     (setq dashboard-items '((recents  . 10)
                             (bookmarks . 5)
                             (projects . 5)
                             (agenda . 5)
                             (registers . 5)))
     (setq dashboard-projects-switch-function 'projectile-persp-switch-project)
     (setq dashboard-week-agenda t)
   #+END_SRC


** Perspective

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'perspective)
     (customize-set-variable 'persp-mode-prefix-key (kbd "C-c M-p"))
     (persp-mode)
     (maybe-install-and-require 'persp-projectile)
   #+END_SRC

** Crux

   Useful editing commands

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'crux)
     (global-set-key (kbd "s-r") 'crux-recentf-find-file)
     (global-set-key (kbd "C-c M-k") 'crux-kill-other-buffers)
     (global-set-key (kbd "C-c P") 'crux-kill-buffer-truename)
   #+END_SRC

* Text Modes

** Text Mode Basics

   If we are in a text mode we want flyspell and auto-fill-mode.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'flyspell)
     (add-hook 'text-mode-hook
               (lambda ()
                       ;; (flyspell-mode 1)
                       ;; (diminish 'flyspell-mode)
                       (auto-fill-mode 1)
                       (diminish 'auto-fill-function)))
   #+END_SRC

*** Delete that trailing whitespace

    Trailing whitespace just causes trouble with diffs and version
    control. So let's get rid of it.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'before-save-hook
                (lambda nil
                  (delete-trailing-whitespace)))
    #+END_SRC

** org-mode

   I also use org-mode on its own and would like to use it more. I
   used to be a complete planner-mode addict. I've never really
   gotten into org-mode in the same way. Having a way to sync to
   trello and link to my email, magit and everything else keeps
   making me want to try though.

*** Single space sentences

    #+BEGIN_SRC emacs-lisp
     (setq sentence-end-double-space nil)
    #+END_SRC

*** fontify

    This is all written in org-mode. It would be good if the source
    code examples were fonitfies according to their major mode.

    #+BEGIN_SRC emacs-lisp
      (setq org-src-fontify-natively t)
    #+END_SRC

*** spelling

    Switch on Flyspell for org-mode

    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook 'turn-on-flyspell)
    #+END_SRC

*** Set follow links on return

    #+BEGIN_SRC emacs-lisp
     (setq org-return-follows-link t)
    #+END_SRC
*** org-cheatsheet

    Having cheatsheets around is handy. Especially for sprawling
    modes like org-mode.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'helm-orgcard)
      (add-hook 'org-mode-hook
                       (lambda () (local-set-key [s-f1] 'helm-orgcard)))
    #+END_SRC

*** org and magit

    Because sometimes you want to link to that particular commit.

    I added this functionality with this commit: [[magit:~/emacs-configs/otfrom-org-emacs/::commit@1dd7516][1dd7516]]

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'org-magit)
    #+END_SRC

*** org-feed

    I really quite liked google as a blog reader. Before that I used
    to use Bloglines, which I liked more. Now I find that I can use
    emacs and org-mode to read RSS and atom.

    #+BEGIN_SRC emacs-lisp
      (setq org-feed-retrieve-method 'curl)
    #+END_SRC

*** Open text in adoc mode

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'adoc-mode)
     (maybe-install-and-require 'markup-faces)
     (add-to-list 'auto-mode-alist (cons "\\.txt\\'" 'adoc-mode))
    #+END_SRC

*** ox-reveal

    [[https://github.com/hakimel/reveal.js/][reveal.js]] is a great way of making pretty presentations,
    especially if you have a fair bit of code. Kris Jenkins suggested
    that [[https://github.com/yjwen/org-reveal][ox-reveal]] would be a great way of generating the slides for
    reveal.js.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'ox-reveal)
    #+END_SRC

    As a part of the installation we need to point at where we have
    our copy of reveal.js. It uses a lot of disk space, but put it
    into a sub directory for each presentation. Then you can serve it
    up using http-server in node or a python webserver locally and
    then things like speaker notes will work. Full screen in Lion is
    still b0rken. Yet another reason to go over to linux.

    #+BEGIN_SRC emacs-lisp
      (setq org-reveal-root "file::///home/chris/reveal.js/")
    #+END_SRC

*** Scheduling, Project Management, Time Keeping

**** todo keywords

     I seem to have come to some conclusions about which todo keywords
     actually work for me. The config below doesn't quite work yet
     though, so I'm still using per file keywords.

     #+BEGIN_SRC emacs-lisp
             (setq org-todo-keywords
                    '((sequence "TODO(t)" "CCC(c!)" "DOING(g!)" "|" "DONE(d!)")
                      (sequence "WAITING(w@/!)" "BLOCKED(b@/!)" "|")
                      (sequence "PROJECT(p!)" "|" "COMPLETE(m!)")
                      (sequence "|"  "CANCELLED(n@/!)" "PHONE" "MEETING" "DECISION" "NOTE" "EMAIL")))
     #+END_SRC

**** Log when things are done

     I quite like to see in the agenda log when I've done things and
     I'd like to be prompted for a note as well.

     #+BEGIN_SRC emacs-lisp
        (setq org-log-done 'note)
     #+END_SRC

**** Agenda

***** org-mode and Google Calendar with org-gcal

      Instead of importing google calendar events using a shell script
      and diary mode can we get gcal events into org-mode?

      org-gcal-file-alist, org-gcal-client-id and
      org-gcal-client-secret are all set in [[../local/mellon.el.gpg][mellon.el.gpg]].

      #+BEGIN_SRC emacs-lisp
        (maybe-install-and-require 'org-gcal)
      #+END_SRC

***** Agenda Windows

      I'm not quite sure what possessed the org-mode people to
      presume that they knew best about how my windows should be
      arranged when I look at an agenda. There is a solution to that
      though. Just use the current window, like every other command
      that opens something up. Re-arrange frame indeed.

      #+BEGIN_SRC emacs-lisp
        (setq org-agenda-window-setup 'current-window)
      #+END_SRC

***** Agenda Files

      There are things for me and mine. Things I do for money. Things
      I do for the community I'm in. Let me know if you think my
      worldview is too small.

      And somethings we need in the agenda even though we don't know
      where to file it yet which is why refile is in here.

      #+BEGIN_SRC emacs-lisp
        ;; (setq org-agenda-files
        ;;       '("~/org/refile.org"
        ;;         "~/org/work/world-domination.org"
        ;;         "~/org/work.org"
        ;;         "~/org/community.org"
        ;;         "~/org/personal.org"
        ;;         "~/org/mc-cal.org"
        ;;         "~/org/otfrom-cal.org"
        ;;         "~/org/ldnclj-cal.org"))
      #+END_SRC

***** Agenda Sorting

      I want to sort my tasks in the agenda by the deadline, then
      schedule and then priority.

      Todo items I want to sort by deadline, schedule and then
      priority, but I usually filter out the things with deadline and
      schedule time in most agenda views.

      Tags and search are the same as the default values.

      #+BEGIN_SRC emacs-lisp
        (setq org-agenda-sorting-strategy
              '((agenda time-up
                        timestamp-up
                        priority-down
                        habit-down
                        category-keep)
                (todo priority-down
                      category-keep
                      todo-state-up
                      tag-up
                      effort-down)
                (tags priority-down
                      category-keep)
                (search category-keep)))
      #+END_SRC

***** Custom Agendas

      The real power of org-agenda starts to kick in when you create
      your own custom agenda commands that get the things *you* want
      out of your org files.

****** What am I doing in the Current Cake Countdown?

       My default view, as I mostly use org for keeping my working
       days in line is around the Current Cake Countdown, which is
       what we call our iterations as we celebrate the end of each
       iteration with cake and don't do a lot of fast running as we
       are programmers.

       This is a composite agenda view that shows the agenda by date
       at the top and the todo list below that.

       The agenda spans one week and starts on a Wednesday (weekday
       3).

       It filters the todo list is a pretty bad way as I was having
       quite a bit of trouble with some of the regular expressions. I
       do have it so that it finds the DOING, CCC, WAITING and BLOCKED
       tasks and skips the DONE ones so that my view isn't too
       cluttered as I try to find the next task.

       It is also skips todo items that have a deadline or are
       scheduled as I have them already in the agenda at the top. It
       also overrides the text that describes the todo list. By
       default it is the regular expression we are using to filter the
       todo list.

       I also remove items that are scheduled or with deadlines from
       the weekly agenda when they are done. This is so I can keep the
       clutter down in this view and decide on what I want my next
       step to be.

       The todo items are also filtered to only show things that have
       the Owner property set to my name.

       #+BEGIN_SRC emacs-lisp
         (setq org-agenda-custom-commands
               '(("Cm" "My Current Cake Countdown"
                  ((agenda "My Current Cake Countdown"
                           ((org-agenda-span 'week)
                            (org-agenda-start-on-weekday 4)
                            (org-agenda-skip-deadline-if-done t)
                            (org-agenda-skip-scheduled-if-done t)))
                   (tags-todo "TODO={^[DCWB].+[^E]$}+Owner=\"Bruce\""
                              ((org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                               (org-agenda-overriding-header "My tasks for the Current Cake Countdown: ")))))))
       #+END_SRC

****** My Window

       I need to know what I was doing on the last working day and I'd
       like to know what is coming up in the next 7 days.

       #+BEGIN_SRC emacs-lisp
         (add-to-list
          'org-agenda-custom-commands
          '("Cn" "My Window"
            ((agenda "My Window"
                     ((org-agenda-span 10)
                      (org-agenda-start-day "-3d")
                      (org-agenda-skip-deadline-if-done t)
                      (org-agenda-skip-scheduled-if-done t)))
             (tags-todo "TODO={^[DCWB].+[^E]$}+Owner=\"Bruce\""
                        ((org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))
                         (org-agenda-overriding-header "My window."))))))
       #+END_SRC

****** What is the whole team doing in the Current Cake Countdown?

       This is basically the same view as above, but without filtering
       on my name in the todo list.

       It also has a column format so we can see how our estimates are
       working against our effort. We're not using this all that much
       as doing team organisation with org-mode and git didn't work
       all that well.

       The tags-todo filter also limits things that are in the MC
       category, as this is just a list for work and not personal
       things.

       #+BEGIN_SRC emacs-lisp
         (add-to-list
          'org-agenda-custom-commands
          '("Ct" "Team Current Cake Countdown"
            ((agenda "Current Cake Countdown" ((org-agenda-files '("~/org/work/world-domination.org"))
                                               (org-agenda-span 'week)
                                               (org-agenda-start-on-weekday 4)
                                               (org-agenda-skip-deadline-if-done t)
                                               (org-agenda-skip-scheduled-if-done t)))
             (tags-todo "+CATEGORY=\"MC\"+TODO={^[DCWB].+}"
                        ((org-agenda-overriding-header "The team's tasks for the Current Cake Countdown: ")
                         (org-agenda-overriding-columns-format
                          "%60ITEM(Task) %8CATEGORY %8Owner %8Effort(Estimated Effort){:} %CLOCKSUM"))))))
       #+END_SRC

****** What are my available projects?

       I try to keep things out of my head and recorded some place. I
       need to be able to review the projects out there and find the
       tasks I want to do next.

       #+BEGIN_SRC emacs-lisp
         (add-to-list
          'org-agenda-custom-commands
          '("P" "Available Projects"
            ((tags-todo "TODO=\"PROJECT\""
                         ((org-agenda-overriding-header "Available projects."))))))
       #+END_SRC

****** org-agenda hotkey

       #+BEGIN_SRC emacs-lisp
         (global-set-key (kbd "C-c a") 'org-agenda)
       #+END_SRC

**** Time Tracking and Estimates

     org-mode is huge. It does so much, but my reason for using it
     was so that I could track effort vs estimates. It makes me
     happier than a burn down chart, but probably just because I'm
     writing elisp to do it rather than excel or google docs. This
     hack works on my mind, but YMMV.

***** clocking in, out and persistence

      It is true, emacs crashes, I forget to clock out, there is just
      life, ok? So, when we clock in to a new task we'll be prompted
      to complete the time for the old task. Just to keep things
      straight.

      There is more about measuring idle time in the org-mode docs
      [[http://orgmode.org/manual/Resolving-idle-time.html][here]].

      #+BEGIN_SRC emacs-lisp
        (setq org-clock-persist 'history)
        (org-clock-persistence-insinuate)
      #+END_SRC

***** Tracking effort vs estimates with clocksum

      I think of days as being working days rather than groups of 24
      hours (I'm damaged, what can I say). So I want to see sums of
      times always in hours rather than as days. Otherwise I just get
      confused and wonder why spending three eight hour days working on
      something gets summed up as just one day.

      I found out about this bit of configuration on [[http://stackoverflow.com/questions/17929979/emacs-org-mode-how-to-stop-total-in-column-view-showing-number-of-days][Stack Overflow]].

      This is really handy when looking at things in column mode in
      org. I use column mode as an alternative to burn down charts to
      track effort vs estimates.

      #+BEGIN_SRC emacs-lisp
        (setq org-time-clocksum-format
              '(:hours "%d" :require-hours t :minutes ":%02d" :require-minutes t))
      #+END_SRC

**** Put those logs in a drawer

     It may be big and heavy and wood, but mostly I don't want to see
     log messages for state change.

     #+BEGIN_SRC emacs-lisp
       (setq org-log-into-drawer t)
     #+END_SRC

     We also want to put the clocking in and out into the drawer.

     #+BEGIN_SRC emacs-lisp
       (setq org-clock-into-drawer t)
     #+END_SRC

**** You can depend on...

     The sub tasks that are underneath the main task.

     #+BEGIN_SRC emacs-lisp
       (setq org-enforce-todo-dependencies t)
     #+END_SRC

*** Capturing, Templates and Refiling

**** Default Notes File

     I don't want to think about things when I'm just capturing
     them. I can refile them later.

     #+BEGIN_SRC emacs-lisp
       (setq org-default-notes-file (concat org-directory "/refile.org"))
     #+END_SRC

**** Capture Hot Key

     Let's capture things with a quick Vulcan Nerve Pinch on
     C-c o.

     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-c o") 'org-capture)
     #+END_SRC

**** Capture Templates

     To do, respond, notes, journals, meetings and phone calls. These
     are the things we want to keep track of and clock in and out of
     let's see how we get on with them.

     We also have a way of tracking things we are doing RFN as well
     as capturing things for the future.

     #+BEGIN_SRC emacs-lisp
       (setq org-capture-templates
             '(("c" "Contacts" entry (file "~/org/contacts.org")
                "* %(org-contacts-template-name)\n:PROPERTIES:\n:EMAIL: %(org-contacts-template-email)\n:PHONE:\n:ALIAS:\n:NICKNAME:\n:IGNORE:\n:ICON:\n:NOTE:\n:ADDRESS:\n:BIRTHDAY:\n:LAST_READ_MAIL:\n:END:" :empty-lines-after 1)
               ("t" "Doing RIGHT NOW" entry (file+datetree org-default-notes-file)
                "* DOING %?\n%n\n%U\n%a\n" :clock-in t :clock-resume t :empty-lines-after 1)
               ("f" "Do in the Future" entry (file+datetree org-default-notes-file)
                "* TODO %?\n%^{Owner}p\n%U\n%a\n" :empty-lines-after 1)
               ("r" "respond" entry (file+datetree org-default-notes-file)
                "* TODO Respond to %:from on %:subject\nSCHEDULED: %t\n%^{Owner}p\n%U\n%a\n"
                :clock-in t :clock-resume t :empty-lines-after 1)
               ("n" "note" entry (file+datetree org-default-notes-file)
                "* %? :NOTE:\n%U\n%a\n" :clock-resume t :empty-lines-after 1)
               ("j" "Journal" entry (file+datetree org-default-notes-file)
                "* %?\n%U\n" :clock-in t :clock-resume t :empty-lines-after 1 :empty-lines-after 1)
               ("m" "Meeting" entry (file+datetree org-default-notes-file)
                "* MEETING with %? :MEETING:\n%^{Owner}p\n%U" :clock-in t :clock-resume t :empty-lines-after 1)
               ("p" "Phone call" entry (file+datetree org-default-notes-file)
                "* PHONE %? :PHONE:\n%^{Owner}p\n%U" :clock-in t :clock-resume t :empty-lines-after 1)))
     #+END_SRC

**** Refiling rules

     We want to be able to refile things in the file we are currently
     in and in files that we create our agenda from.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-targets
             '((nil :maxlevel . 9)
               (org-agenda-files :maxlevel . 9)))
     #+END_SRC

*** org and the pomodoro technique

    When I need to just grind through something or find a way to keep
    myself focused when I'm having trouble I like to use the
    [[http://www.pomodorotechnique.com/][pomodoro technique]]. Luckily there is org-pomodoro that let's us
    put these two great things together.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'org-pomodoro)
      (add-hook 'org-mode-hook
                (lambda () (local-set-key (kbd "M-s-p") 'org-pomodoro)))
    #+END_SRC

*** redtick for pomodoro

    Bruce recommended redtick for pomodoro's outside of org mode so
    going to give it a go.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'redtick)
    #+END_SRC

**** A hotkey in Org Agenda

     I can clock in and out in Org Agendas, I'd like to be able to
     start Pomodoros as well.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'org-agenda-mode-hook
                 (lambda () (local-set-key (kbd "P") 'org-pomodoro)))
     #+END_SRC

*** Activate Appointment Mode

    And now that we have our ical stuff in our diary we'll want
    notifications inside emacs too as we don't have gmail and google
    calendar open all the time.

    #+BEGIN_SRC emacs-lisp
      (appt-activate 1)
    #+END_SRC

*** Default Agenda Hotkey

    M-f11 so we can see our default agenda quickly.

    #+BEGIN_SRC emacs-lisp
      (defun default-agenda ()
        (interactive)
        (org-agenda nil "Cn"))
      (global-set-key [M-f11] 'default-agenda)
    #+END_SRC

*** Babel mode language load

    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((R . t)
         (emacs-lisp . t)
         (shell . t)
         (clojure . t)
         (http . t)
         (java . t)
         (sql . t)
         (dsq . t)
         ;;(scala . t)
         ))
      (setq org-babel-clojure-backend 'cider)
    #+END_SRC

*** Org bullets

    Make org mode bullets look a bit more like bullets and less like
    asterisks.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'org-bullets)
     (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    #+END_SRC


** html, sgml, xml


*** html non lisp paredit

    #+BEGIN_SRC emacs-lisp
      (add-hook 'html-mode-hook 'my-paredit-nonlisp)
      (add-hook 'mhtml-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

*** web mode

    Try out web mode.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'web-mode)
      (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.hmtl?\\'" . web-mode))
      (setq web-mode-markup-indent-offset 2)
      (setq web-mode-css-markup-indent-offset 2)
      (setq web-mode-code-indent-offset 2)
      (add-hook 'web-mode-hook 'my-paredit-nonlisp)
      (maybe-install-and-require 'company-web)
      (eval-after-load 'web-mode
        '(add-to-list 'company-backends 'company-web))

    #+END_SRC

*** tagedit

    This gives us paredit like editing for html

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'tagedit)
      ;; (eval-after-load "sgml-mode"
      ;;   '(progn
      ;;      (require 'tagedit)
      ;;      (tagedit-add-paredit-like-keybindings)
      ;;      (add-hook 'html-mode-hook (lambda () (tagedit-mode 1)))))
    #+END_SRC

    I quite like the sound of the experimental editing stuff. Let's
    put it in and see if it helps or destroys our code.

    #+BEGIN_SRC emacs-lisp
;;      (tagedit-add-experimental-features)
    #+END_SRC

*** Yaml

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'yaml-mode)
    #+END_SRC


*** css

    I should probably look at adding more sugar to this.

*** cleanup buffer

    Borrowed from Magnars gist https://github.com/magnars/.emacs.d/blob/master/defuns/buffer-defuns.el

    #+begin_src emacs-lisp
      (defun untabify-buffer ()
             (interactive)
             (untabify (point-min) (point-max)))

      (defun indent-buffer ()
        (interactive)
        (indent-region (point-min) (point-max)))

      (defun cleanup-buffer ()
        "Perform a bunch of operations on the whitespace content of a buffer.
      Including indent-buffer, which should not be called automatically on save."
        (interactive)
        (untabify-buffer)
        (delete-trailing-whitespace)
        (indent-buffer))
      (global-set-key (kbd "C-c n") 'cleanup-buffer)
    #+end_src

**** paredit

     I *always* want my parens to match (except in text modes).

     #+BEGIN_SRC emacs-lisp
       (add-hook 'css-mode-hook 'paredit-mode)
       (add-hook 'css-mode-hook 'my-paredit-nonlisp)
     #+END_SRC

**** rainbow mode

     And I want to see the colours I'm using.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'css-mode-hook 'rainbow-mode)
     #+END_SRC

**** eldoc

     And who doesn't want eldoc tips when they are editing things.

     #+BEGIN_SRC emacs-lisp
;;       (maybe-install-and-require 'css-eldoc)
     #+END_SRC

**** helm support

     And to be able to navigate around our selectors using helm. And
     then we want to make it a headline key just like in our other
     modes.

     #+BEGIN_SRC emacs-lisp
       (maybe-install-and-require 'helm-css-scss)
       (add-hook 'css-mode-hook
                 (lambda () (local-set-key (kbd "s-h") 'helm-css-scss)))
     #+END_SRC

** markdown

   I love org-mode, but lots of other systems use markdown, github
   wiki pages being a very good example.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'markdown-mode)
     (setq markdown-command "pandoc")
   #+END_SRC

*** Github Flavouring

    I pretty much *always* want to do [[http://github.github.com/github-flavored-markdown/][github flavoured markdown]], so
    let's just change that auto-mode-alist.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '(".md$" . gfm-mode))
    #+END_SRC

**** Github Flavoured Preview

     We also need to change the preview as the standard preview
     doesn't render github flavoured markdown correctly. I've
     installed markdown Preview+ as a Chrome Extension and associated
     .md files with Chrome on Mac OS X.

     This is all a bit broken really, but will work for now. I'm sorry
     that it is like this and I'm sure some day I'll fix it. This also
     means that you use markdown-open rather than markdown-preview.

     #+BEGIN_SRC emacs-lisp
       (setq markdown-open-command "open")
     #+END_SRC

*** helm markdown headlines

    I want super-h to work and give me headlines just like in
    org-mode. I feel this could perhaps be a bit better, but this will
    do for now.

    #+BEGIN_SRC emacs-lisp
      (defun helm-markdown-headlines ()
        "Display headlines for the current Clojure file."
        (interactive)
        (helm :sources '(((name . "Markdown Headlines")
                          (volatile)
                          (headline "^[#]")))))

      (add-hook 'markdown-mode-hook
                (lambda () (local-set-key (kbd "s-h") 'helm-markdown-headlines)))
    #+END_SRC

** adoc mode for asciidoc

   I'm using adoc mode for asciidoc files

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'adoc-mode)
     (add-to-list 'auto-mode-alist (cons "\\.asciidoc\\'" 'adoc-mode))
   #+END_SRC

** evil mode for my vim friends

   I am mainly including this for my friends who use vim to be able to
   pair with me and so I can use evil-search-symbol-forward and
   evil-search-symbol-backward

   #+BEGIN_SRC emacs-lisp
     ;; (maybe-install-and-require 'evil)
     ;; (global-set-key (kbd "C-*") 'evil-search-word-forward)
     ;; (global-set-key (kbd "C-#") 'evil-search-word-backward)
   #+END_SRC

* Communication Modes

** twittering-mode

   I have been accused by many ([[http://twitter.com/rrees][Robert Rees]] and [[http://twitter.com/cluttercup][Jane Dickson]] to name
   but two) of being constantly on twitter. This is mostly fair. I'm
   curious to see the revision history of this file and see if I
   change this description before I declare .emacs bankruptcy again.

   The best twitter client I've found is twittering-mode.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'twittering-mode)
   #+END_SRC

   I *don't* want to see the the status messages in the mini-buffer
   when twitter fetches things.

   #+BEGIN_SRC emacs-lisp
     (setq twittering-url-show-status nil)
   #+END_SRC

   I like to have the icon pictures.

   #+BEGIN_SRC emacs-lisp
     (setq twittering-icon-mode 1)
     (setq twittering-use-icon-storage t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; (add-hook 'twittering-edit-mode-hook
     ;;     (lambda () (ispell-minor-mode) (flyspell-mode)))
   #+END_SRC

   You can configure it to use a local, encrypted file for the
   credentials as well, which makes re-connecting easier and
   reasonably secure.

   This didn't really work until I fixed the exec-path to get gpg in
   it, which is in /usr/local/bin on my machine, so you need to add
   the bits from [[$PATH is broken][$PATH is broken]] in the [[Macintosh Specific Setup][Macintosh Specific Setup]].

   #+BEGIN_SRC emacs-lisp
     (setq twittering-use-master-password t)
   #+END_SRC

   By default I want to get my replies and direct messages.

   #+BEGIN_SRC emacs-lisp
     (setq twittering-initial-timeline-spec-string
           '(":home"
             "agile_geek/Friends"
             ":replies"
             ":direct_messages"))
   #+END_SRC

   I also want to slow it down. It updates way too often when I'm not
   interested.

   #+BEGIN_SRC emacs-lisp
     (setq twittering-timer-interval (* 60 30))
   #+END_SRC

** Tweet Button

   Sometimes I just want to scream. Twitter lets me do that.

   #+BEGIN_SRC emacs-lisp
      (global-set-key [M-f6] 'twittering-update-status-interactive)
   #+END_SRC

*** Tweeps I know with a hotkey

    You won't believe it, but twitter is actually important to my
    job. When I don't pay attention to it important things actually
    happen there. Honest!

    #+BEGIN_SRC emacs-lisp
      (defun tweeps-i-know ()
        (interactive)
        (let* ((p-i-k "chrishowejones/friends")
               (twoot (get-buffer p-i-k)))
          (if twoot
              (switch-to-buffer twoot)
            (twittering-visit-timeline p-i-k))))
      (global-set-key [C-f11] 'tweeps-i-know)
    #+END_SRC


** jabber.el for gtalk and other jabber servers

   It looks like there will be a time in the near future when Google
   will no longer support jabber/xmpp. There might be a new mode to
   support hangouts when that happens or I might have to go over to
   running my own xmpp server or find someone else who is doing one,
   or just abandon jabber for irc. Until that time I'll have a go with
   jabber.el.

   #+BEGIN_SRC emacs-lisp
     ;; (maybe-install-and-require 'jabber)
   #+END_SRC

   The setup for the jabber-account-list is in my private gpg
   encrypted mellon.el file.

   We also want to be able to store a local history of our chats.

   #+BEGIN_SRC emacs-lisp
     ;; (setq
     ;;   jabber-history-enabled t
     ;;   jabber-use-global-history nil
     ;;   jabber-backlog-number 40
     ;;   jabber-backlog-days 30)
   #+END_SRC

   And we want URLs to be clickable.

   #+BEGIN_SRC emacs-lisp
     ;; (add-hook 'jabber-chat-mode-hook 'goto-address)
   #+END_SRC

   And those BIG AVATARS are just TOO BIG, so let's get rid of them.

   #+BEGIN_SRC emacs-lisp
;;     (setq jabber-chat-buffer-show-avatar nil)
   #+END_SRC

   And while we want to know when we receive messages having something
   flicker in the echo area every time someone's status changes is
   just waaaaay too chatty.

   #+BEGIN_SRC emacs-lisp
  ;;   (setq jabber-alert-presence-hooks nil)
   #+END_SRC

   A convenience binding for firing up all the jabber connections
   would be handy.

   #+BEGIN_SRC emacs-lisp
    ;; (global-set-key [f6] 'jabber-connect-all)
   #+END_SRC

** irc, currently with erc

   Internet Relay Chat is a great way of talking to lots of
   interesting people in what feels a bit like a pub.
*** Connect to freenode

    According to the [[http://freenode.net/irc_servers.shtml][freenode]] site we should be connecting to
    chat.freenode.net.

    #+BEGIN_SRC emacs-lisp
      (setq erc-server "chat.freenode.net")
    #+END_SRC

*** Tracking

    We want to highlight pals and diminish fools, but leave out when
    people leave and join. The list of all valid message types can be found at
    https://www.alien.net.au/irc/irc2numerics.html

    #+BEGIN_SRC emacs-lisp
      ;; (erc-track-mode t)
      ;; (setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
      ;;                                  "324" "329" "332" "333" "353" "477"))

      ;; ;; don't show any of this
      ;; (setq erc-hide-list '("JOIN" "PART" "QUIT" "NICK"))
    #+END_SRC

      These are all of the channels I join by default. Some big data ones
      like #cascalog and #hadoop. Some clojure ones such as
      #liberator, #clojure, #clojurewerkz, #lndclj. Some devopsy ones
      like #jclouds and #pallet. Some communities that do good
      like #ukodi and ##cleanweb. And ones for Mastodon C like #kixi.

      #+BEGIN_SRC emacs-lisp
      (setq erc-autojoin-channels-alist '(("freenode.net" "#clojure" "#clojurescript" "##virtualJUG")))
      #+END_SRC

*** Credentials

    My credentials are in mellon.el of course. This is where I set
    erc-user-full-name, erc-email-user-id, erc-nick and erc-password. I
    also keep my erc-pals and erc-fools in here. Try to guess which
    list you might be in. :-D

*** Switch to irc

    What we want to do is switch to irc if we've got something
    running. If not, then start erc up.

    #+BEGIN_SRC emacs-lisp
      (defun switch-to-irc ()
        (interactive)
        (let ((buffers (and (fboundp 'erc-buffer-list)
                            (erc-buffer-list))))
          (if buffers
              (switch-to-buffer (car buffers))
            (erc :server "irc.freenode.net"))))
    #+END_SRC

*** Logging

    Handy to save the irc logs so we have a way of finding interesting
    things again after hearing about them on irc.

    #+BEGIN_SRC emacs-lisp
      (require 'erc-log)
      (erc-log-enable)
      (setq erc-log-channels-directory (concat user-emacs-directory "erc/logs/"))
      (setq erc-save-buffer-on-part t)
    #+END_SRC

*** notify on nick

    irc is great fun, but I need something to ping me when they want
    me on a channel.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'erc-modules 'notify)
      (add-to-list 'erc-modules 'notifications)
    #+END_SRC


** email
*** Sending Mail with msmtp

    We want to send mail with msmtpq, which sends the mail if the
    interwebs are up and queues it if the internet is down.

    At the moment I can't get msmtpq working consistently so I'm just
    doing msmtp and waiting before I reply.

    #+BEGIN_SRC emacs-lisp
      (setq message-send-mail-function 'message-send-mail-with-sendmail)
      (setq
       sendmail-program "/usr/bin/msmtp"
       ;;sendmail-program "~/bin/msmtpq"
       mail-specify-envelope-from t
       message-sendmail-f-is-evil nil
       mail-envelope-from 'header
       message-sendmail-envelope-from 'header)

      (setq message-kill-buffer-on-exit t)
    #+END_SRC

**** Queueing mail

     Sometimes we want to send mail when we don't have any network. We
     can queueing email with the following.

     #+BEGIN_SRC emacs-lisp
       (setq smtpmail-queue-mail  nil  ;; start in non-queuing mode
             smtpmail-queue-dir   "~/Maildir/queue/cur")
     #+END_SRC

**** Choosing the right email address with gnus-alias

     Our ~/.msmtprc file has a from field in addition to a user
     field. It uses the from field to match against the account as it
     sends email so that it goes via the correct server. This is much
     easier than having to pass through -a <account name> on the
     command line the way you used to. Luckily I've not had to suffer
     through that and can use gnus-alias.

     Remember when setting up the Fcc directory that it should point
     at a real maildir directory.

     #+BEGIN_SRC emacs-lisp
              ;; (maybe-install-and-require 'gnus-alias)
              ;; ;; Define two identities, "home" and "work"
              ;; (setq gnus-alias-identity-alist
              ;;       '(("gmail"
              ;;          "Chris Howe-Jones <chris.howejones@gmail.com>" ;; Sender address
              ;;          nil
              ;;          "Chris Howe-Jones <chris.howejones@gmail.com>"
              ;;          (("Fcc" . "/home/bld/maildir/gmail/sent"))
              ;;          nil ;; No extra body text
              ;;          "~/.signature")
              ;;          ))
              ;; ;; Use "home" identity by default
              ;; (setq gnus-alias-default-identity "gmail")
              ;; Define rules to match work identity
       ;;       (setq gnus-alias-identity-rules
       ;;             '(("DevCycle" ("to" ".*devcycle.com" both) "DevCycle")))
     #+END_SRC

*** email with mu and mu4e

    [[http://www.djcbsoftware.nl/code/mu/][mu4e]] is a maildir based email indexer with an emacs client. It
    does a good job of moving files around to the right directories so
    that syncing with imap and a local store actually works in
    addition to having good indexing with mu.

    We installed mu4e from a source tarball. It put its configuration
    files in /usr/local/share/emacs/site-lisp/mu4e/.

    #+BEGIN_SRC emacs-lisp
 ;;   (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e/")
 ;;   (require 'mu4e)
 ;;   (setq mu4e-user-mail-address-list (list "chris.howejones@gmail.com"))
    #+END_SRC

**** Don't hog my minibuffer

     I actually consider the default behaviour of the mu4e indexer to
     be quite rude. It overwrites the minibuffer while I'm trying to
     do things and basically makes emacs unusable for the minutes when
     it is re-indexing everything.

     I know I need to divide my email into years or months and add a
     .noindex into some directories, but it really is just a bit
     much even with that.

     #+BEGIN_SRC emacs-lisp
;;       (setq mu4e-hide-index-messages 1)
     #+END_SRC

**** Fetching mail

     We use offlineimap to get our mail and want to get it every 13
     minutes, just to be lucky.

     #+BEGIN_SRC emacs-lisp
       (setq mu4e-get-mail-command "offlineimap")
       (setq mu4e-update-interval (* 32 60))
     #+END_SRC

**** Shortcuts

     A few quick shortcuts to let us jump to the folders we are
     interested in.

     #+BEGIN_SRC emacs-lisp
;;       (setq mu4e-maildir-shortcuts
;;             '(("/gmail/INBOX" . ?p)))
     #+END_SRC

**** Multiple Accounts

     There is a good little howto on using multiple accounts with mu4e
     [[http://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html][here]].

***** The default account.

      I've defaulted to my mastodonc account as it is easier to
      explain to my friends about my work account than my clients
      about my personal account.

      #+BEGIN_SRC emacs-lisp
;;        (setq mu4e-refile-folder "/gmail/all"
;;              mu4e-sent-folder "/gmail/sent"
;;              mu4e-drafts-folder "/gmail/drafts"
;;              mu4e-trash-folder "/gmail/trash"
;;              user-mail-address "chris.howejones@gmail.com"
;;              message-signature-file "/home/chrishowe-jones/.signature"
;;              user-mail-address "chris.howejones@gmail.com")
      #+END_SRC

***** The account switching

      I'll copy and paste these instructions from the web page here
      just to make it clear what I'm doing. Again, remember that we
      handle the smtp bit differently and the account switching there
      is done based on the From: field of the message.

      #+BEGIN_QUOTE
      Then create a variable my-mu4e-account-alist, which should
      contain a list for each of your accounts. Each list should
      start with the account name, (which must be identical to the
      account's directory name under ~/Maildir), followed by
      (variable value) pairs:
      #+END_QUOTE

      #+BEGIN_SRC emacs-lisp
;;        (defvar my-mu4e-account-alist
;;          '(("devcycle"
;;             (mu4e-refile-folder "/devcycle/all")
;;             (mu4e-sent-folder "/devcycle/sent")
;;             (mu4e-drafts-folder "/devcycle/drafts")
;;             (mu4e-trash-folder "/devcycle/trash")
;;             (user-mail-address "chris@devcycle.com")
;;             (message-signature-file "/home/chrishowe-jones/.signature.work"))
;;            ("gmail"
;;             (mu4e-refile-folder "/gmail/all")
;;             (mu4e-sent-folder "/gmail/sent")
;;             (mu4e-drafts-folder "/gmail/drafts")
;;             (mu4e-trash-folder "/gmail/trash")
;;             (user-mail-address "chris.howejones@gmail.com")
;;             (message-signature-file "/home/chrishowe-jones/.signature"))))
      #+END_SRC

***** Add a switch function to the hook

      I think it is great that mu4e is this extensible, but I am a bit
      confused as to whey the following function isn't a part of mu4e
      that you can just turn on.

      #+BEGIN_SRC emacs-lisp
;;         (defun my-mu4e-set-account ()
;;               "Set the account for composing a message."
;;               (let* ((account
;;                       (if mu4e-compose-parent-message
;;                           (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
;;                             (string-match "/\\(.*?\\)/" maildir)
;;                             (match-string 1 maildir))
;;                         (completing-read (format "Compose with account: (%s) "
;;                                                  (mapconcat #'(lambda (var) (car var)) my-mu4e-account-alist "/"))
;;                                          (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
;;                                          nil t nil nil (caar my-mu4e-account-alist))))
;;                      (account-vars (cdr (assoc account my-mu4e-account-alist))))
;;                 (if account-vars
;;                     (mapc #'(lambda (var)
;;                               (set (car var) (cadr var)))
;;                           account-vars)
;;                   (error "No email account found"))))

;;        (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
      #+END_SRC

**** Unicode

     We want to be able to read non-ascii characters.

     #+BEGIN_SRC emacs-lisp
       ;; Use fancy chars
;;       (setq mu4e-use-fancy-chars t)
     #+END_SRC

**** Gmail quirks and feature simulations

***** Including related messages

      I want to be able to see everything that goes with the thread
      when I'm looking at messages in my inbox.

      #+BEGIN_SRC emacs-lisp
;;        (setq mu4e-headers-include-related t)
      #+END_SRC

***** Skip duplicates

      All mail contains duplicates of what is in INBOX, sent, trash
      and others. So if we want to include the related we'll also want
      to skip the duplicates.

      #+BEGIN_SRC emacs-lisp
;;        (setq mu4e-headers-skip-duplicates t)
      #+END_SRC

**** View html only emails in the browser

     With this added we can view html only emails in the browser by
     hitting aV.

     #+BEGIN_SRC emacs-lisp
;;       (add-to-list 'mu4e-view-actions
;;                    '("ViewInBrowser" . mu4e-action-view-in-browser) t)
     #+END_SRC

**** mu4e and org-mode capturing

     We want to be able to link to messages in org-mode. That's part
     of the reason for having email in emacs anyway.

     #+BEGIN_SRC emacs-lisp
;;       (require 'org-mu4e)
     #+END_SRC

**** mu4e and org-contacts

     I want to use org-contacts rather than bbdb.

     #+BEGIN_SRC emacs-lisp
;;       (require 'org-contacts)
;;       (setq org-contacts-files (quote ("~/org/contacts.org")))
;;       (setq mu4e-org-contacts-file  "~/org/contacts.org")
;;       (add-to-list 'mu4e-headers-actions
;;                    '("org-contact-add" . mu4e-action-add-org-contact) t)
;;       (add-to-list 'mu4e-view-actions
;;                    '("org-contact-add" . mu4e-action-add-org-contact) t)
     #+END_SRC

**** And a hot key

     And we want to be able to switch to mu4e quickly so let's set f11
     to be the hot key.

     #+BEGIN_SRC emacs-lisp
;;       (global-set-key [f11] 'mu4e)
     #+END_SRC

** Web Browsing

*** w3m

    I've really had it with bloated browsers gobbling all my memory
    and not playing nicely with org-mode. So, let's try w3m for a
    while shall we?

    #+BEGIN_SRC emacs-lisp
;;      (maybe-install-and-require 'w3m)
;;      (setq browse-url-browser-function 'browse-url-generic)
      (global-set-key "\C-xm" 'browse-url-at-point)
      (setq w3m-use-cookies t)
    #+END_SRC


** Hailing Frequencies or comms

   It is good that jabber and erc die when I put the computer to
   sleep. What I'd like to be able to do is bring them all back up
   with a simple Vulcan grip.

   #+BEGIN_SRC emacs-lisp
     (defun comms-up ()
       (interactive)
       (twittering-mode)
       (erc))

     (defun comms ()
       (interactive)
       (delete-other-windows)

       (if (< (frame-width) 240)
           (progn
             ;; create 2 columns
             (split-window-right)

             ;; 2 rows on the left for twitter
             (split-window-below)

             ;; 3 rows on the right for erc and jabber
             (window-number-select 3)
             (split-window-below)
             (split-window-below)

             ;; Balance it all
             (balance-windows)

             ;; twitter on the left
             (window-number-select 1)
             (switch-to-buffer "agile_geek/friends")
             (window-number-select 2)
             (switch-to-buffer ":replies")

             ;; erc and jabber on the right
             (window-number-select 4)
             (switch-to-buffer "#ldnclj")
             (window-number-select 5)
             (if (get-buffer boss-chat)
                 (switch-to-buffer boss-chat)
               (switch-to-buffer "*-jabber-roster-*"))

             ;; go to and grow the top left window
             (window-number-select 1)
             (enlarge-window 9))
         (progn
           ;; create our 3 columns
           (split-window-right)
           (split-window-right)

           ;; create our 1st 2 rows
           (split-window-below)
           (split-window-below)

           ;; move to the middle and split
           (window-number-select 4)
           (split-window-below)
           (split-window-below)

           ;; move to the right and split
           (window-number-select 7)
           (split-window-below)
           (split-window-below)

           ;; Balance it all
           (balance-windows)

           ;; grow the top left window
           (window-number-select 1)
           (enlarge-window 16)

           ;; shrink the bottom left window
           (window-number-select 3)
           (shrink-window 11)

           ;; set up the buffers as we want
           (window-number-select 1)
           (switch-to-buffer "chrishowejones/Friends")
           (window-number-select 2)
           (switch-to-buffer ":replies")
           (window-number-select 3)
           (switch-to-buffer ":direct_messages")
           (window-number-select 4)
           (org-agenda nil "Cm") ;; My Agenda
           (window-number-select 6)
           (if (get-buffer boss-chat)
                 (switch-to-buffer boss-chat)
               (switch-to-buffer "*-jabber-roster-*"))
           (window-number-select 7)
           (switch-to-buffer "#ldnclj")

           ;; dump the middle window
           (window-number-select 5)
           (delete-window))))

     (global-set-key [C-f6] 'comms-up)
     (global-set-key [C-f12] 'comms)
   #+END_SRC

* Programming Modes
** shell


   #+BEGIN_SRC emacs-lisp
     (global-set-key [C-M-return] 'shell)
     ;; Use bash explicitly cos fancy shells like zsh don't render well in emacs
     (setq explicit-shell-file-name "/bin/zsh")
     (setq shell-file-name "zsh")
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
     (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)
   #+END_SRC

** prog-mode

   prog-mode and the prog-mode-hook are at the basis of most of the
   programming modes in emacs. If we want something set up for
   everything we should do it here.

*** Parentheses
**** Show Them

     We really want to see those parentheses.

     #+BEGIN_SRC emacs-lisp
       (show-paren-mode +1)
     #+END_SRC

**** paredit-mode

     Should I move over to smartparens? Can anyone tell me what is so
     much better about it?

     paredit-mode is a strange one. When you first use it, you will
     hate it. You'll hate the way it won't let you do the things
     you *think* you want to do. Once you get used to it though you
     wonder how you ever did any programming without it.

     #+BEGIN_SRC emacs-lisp
       (maybe-install-and-require 'paredit)
       (diminish 'paredit-mode "()")
       (add-hook 'prog-mode-hook 'paredit-mode)
     #+END_SRC

*** rainbow-delimiters

    Make those delimiters glow with wacky colors so we can see what is
    going on.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'rainbow-delimiters)
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    #+END_SRC

*** rainbow mode

    If we have a color literal it is really nice to have an idea of
    what it is going to look like. This is *really* useful in things
    like editing CSS files with hex color codes.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'rainbow-mode)
      (add-hook 'prog-mode-hook 'rainbow-mode)
      (diminish 'rainbow-mode)
    #+END_SRC

*** highlight-symbol

    I like to see all of the places I'm using the same symbol. This is
    a great visual cue for those times where you've mistyped a variable
    for function name. It isn't quite flymake, but it is handy. It is
    good to see where something is used as well.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'highlight-symbol)
      (add-hook 'prog-mode-hook 'highlight-symbol-mode)
    #+END_SRC

*** flycheck

    Flycheck should give on the fly syntax checking.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'flycheck)

    #+END_SRC
*** color-identifiers-mode

    This is a suggestion from @sw1nn.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'color-identifiers-mode)
      (global-color-identifiers-mode t)
      (diminish 'color-identifiers-mode)
    #+END_SRC

*** yasnippet

    I had some lovely things in skeleton mode ages ago to write out
    boilerplate for C++ and to convert some awful, horrible 100
    parameter PLSQL functions I had to call. yasnippets seems to be
    the one that people are using now to do smaller things than what
    I was doing with skeleton. This is probably a good thing.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'yasnippet)
      (key-chord-define-global "yy" 'yas-expand-from-trigger-key)
      (define-key yas-minor-mode-map (kbd "C-c C-y") 'yas-visit-snippet-file)
    #+END_SRC

**** Snippet Directory

     We need a place to add our snippets for each mode as well. We'll
     put that in snippets.

     #+BEGIN_SRC emacs-lisp
;      (setq yas/root-directory (concat user-emacs-directory "snippets"))
     #+END_SRC

**** Turn it on globally

     And we want to add yasnippets to all modes where we have snippets.

     #+BEGIN_SRC emacs-lisp
       (yas-global-mode 1)
     #+END_SRC

**** Diminish it

     I don't need to see it everywhere though.

     #+BEGIN_SRC emacs-lisp
       (diminish 'yas-minor-mode)
     #+END_SRC

**** Java snippets

     #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'java-snippets)
     #+END_SRC
*** smartscan

    A suggestion from [[http://www.masteringemacs.org/articles/2011/01/14/effective-editing-movement/][Effective Editing]] in [[http://www.masteringemacs.org/][Mastering Emacs]]. This
    allows you to go to the next identifier like the one you are
    currently on by using M-n and M-p.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'smartscan)
      (add-hook 'prog-mode-hook
                '(lambda () (smartscan-mode 1)))
    #+END_SRC

**** paredit spaces for non s-expr langs

     Need to stop insertion of spaces between symbols and parens for
     non s-expr langs

     #+BEGIN_SRC emacs-lisp
     (defun my-paredit-nonlisp ()
       "Turn on paredit mode for non-lisps."
       (interactive)
       (set (make-local-variable 'paredit-space-for-delimiter-predicates)
            '((lambda (endp delimiter) nil)))
         (paredit-mode 1))
     #+END_SRC

** lisp modes

   emacs-lisp and clojure are the two that really go in here for now,
   though in the future scheme and common lisp could be added.

*** lisp hooks

    These are the common lisp hooks we want shared across all lisp
    modes.

    #+BEGIN_SRC emacs-lisp
      (setq lisp-hooks (lambda ()
                         (eldoc-mode +1)
                         (diminish 'eldoc-mode)
                         (define-key paredit-mode-map
                           (kbd "{") 'paredit-open-curly)
                         (define-key paredit-mode-map
                           (kbd "}") 'paredit-close-curly)
                         (local-set-key (kbd "C-;") 'comment-dwim)))
    #+END_SRC

*** emacs-lisp

**** lisp-mode-hook

     Let's add the lisp mode hook to the emacs-lisp-mode

     #+BEGIN_SRC emacs-lisp
       (add-hook 'emacs-lisp-mode-hook lisp-hooks)
     #+END_SRC

**** Pop Up Help in Emacs Lisp

     Thx again to [[http://twitter.com/krisajenkins][Kris Jenkins]] and his [[http://blog.jenkster.com/2013/12/popup-help-in-emacs-lisp.html][blog post]] I've got even yet
     more help with emacs-lisp functions in a popup just like in ac
     stuff in clojure modes. Thanks to [[http://twitter.com/sanityinc][Steve Purcell]] we have an
     improved version that gets faces and vars in addition to
     functions, so in some ways it is even a bit better than what is
     available in cider/clojure-mode (from my understanding anyway).

     #+BEGIN_SRC emacs-lisp
       (require 'popup)

       (defun describe-thing-in-popup ()
         (interactive)
         (let* ((thing (symbol-at-point))
                (help-xref-following t)
                (description (with-temp-buffer
                               (help-mode)
                               (help-xref-interned thing)
                               (buffer-string))))
           (popup-tip description
                      :point (point)
                      :around t
                      :height 30
                      :scroll-bar t
                      :margin t)))
     #+END_SRC

***** The usual help keybinding

      Let's use C-c C-d for describing functions at point as this is
      the binding in cider/nrepl that I'm used to. We'll probably do
      this in other modes as well so we'll make it a local keybinding
      and then it will more or less [[http://en.wikipedia.org/wiki/DWIM][dwim]].
      Let's use C-c C-k (like cider does) to run eval buffer in
      emacs-lisp mode.


      #+BEGIN_SRC emacs-lisp
        (add-hook 'emacs-lisp-mode-hook
                  (lambda () (local-set-key (kbd "C-c C-d") 'describe-thing-in-popup)
                             (local-set-key (kbd "C-c C-k") 'eval-buffer)))
      #+END_SRC

***** auto complete bash style in shell

      I found the autocompletion for shell wasn't working properly
      and didn't work like bash

      #+BEGIN_SRC emacs-lisp
        (maybe-install-and-require 'bash-completion)
        (bash-completion-setup)
      #+END_SRC

*** clojure

    I do *love* coding in clojure. The tool chain has been evolving
    quite a bit over the last few years.

    Everything has gone from being built only with maven to maven
    being just for core and everything else being done with [[http://leiningen.org/][Leiningen]].

    On the emacs side we've gone from the swank and slime, to nrepl
    and nrepl.el, to now we have nrepl and cider.el. Trying to move to
    cider.el is what caused me to declare .emacs.d bankruptcy this
    time and restructure everything.

    Most of the clojure emacs goodness if available in the github
    repo called [[https://github.com/clojure-emacs][clojure-emacs]].
**** boot
***** treat .boot files as clojure source

      #+BEGIN_SRC emacs-lisp
        (add-to-list 'auto-mode-alist '("\\.boot\\'" . clojure-mode))
      #+END_SRC

***** treat boot scripts files as clojure

      #+BEGIN_SRC emacs-lisp
        (add-to-list 'magic-mode-alist '(".* boot" . clojure-mode))
      #+END_SRC

**** cider

***** install

      You can get most of the clojure support by just elpa installing
      cider.

      #+BEGIN_SRC emacs-lisp
        (maybe-install-and-require 'cider)
        (diminish 'cider-mode "Cλ")
      #+END_SRC

***** Popup compilation messages

      Don't pop them up if I'm not in the repl buffer otherwise I
      might go all Bruce Banner on you.

      #+BEGIN_SRC emacs-lisp
        ;; (setq cider-popup-stacktraces t)
      #+END_SRC

***** clojure-mode-hook

      We'll also want to get our lisp-hooks into our clojurey
      goodness. It would be a shame to not have it here.

      #+BEGIN_SRC emacs-lisp
        (add-hook 'clojure-mode-hook lisp-hooks)
        (setq clojure-toplevel-inside-comment-form t)
      #+END_SRC

***** cider-mode-hooks

      There are more things that we'll want that are specific to cider
      mode and the cider interaction buffer.

      #+BEGIN_SRC emacs-lisp
        (setq cider-cljs-lein-repl "")
      #+END_SRC

***** Save cider history

      We also want to save the history of our interactions. There might
      be gold there.

      #+BEGIN_SRC emacs-lisp
        (setq cider-repl-history-file (concat user-emacs-directory "cider-history"))
      #+END_SRC

***** subword-mode

      I also want to be able to navigate to the "-" characters in words.

      #+BEGIN_SRC emacs-lisp
        (add-hook 'cider-mode-hook 'subword-mode)
      #+END_SRC

***** autocomplete

      Popup autocomplete always looks cool and it helps sometimes too.

      We used to have ac-nrepl here, but company is the supported
      thing in cider now and we've loaded that above.

      #+BEGIN_SRC emacs-lisp
        (setq company-tooltip-flip-when-above t)
        (setq company-minimum-prefix-length 2)               ; WARNING, probably you will get perfomance issue if min len is 0!
        (setq company-tooltip-limit 20)                      ; bigger popup window
        (setq company-tooltip-align-annotations 't)          ; align annotations to the right tooltip border
        (setq company-idle-delay .3)                         ; decrease delay before autocompletion popup shows
        (setq company-begin-commands '(self-insert-command)) ; start autocompletion only after typing
        (global-set-key (kbd "C-c /") 'company-files)        ; Force complete file names on "C-c /" key
        (global-set-key (kbd "M-TAB") 'company-complete)
      #+END_SRC

***** compojure indentation rules

      A number of things in compojure don't really indent
      correctly. There are some instructions for fixing that [[https://github.com/weavejester/compojure/wiki/Emacs-indentation][here]].

      #+BEGIN_SRC emacs-lisp
;;        (define-clojure-indent
;;          (defroutes 'defun)
;;          (mlet 1))
      #+END_SRC

***** Don't destroy that repl buffer while pretty printing

      It can be very frustrating to be poking away at clojure data
      structures in the repl and then accidentally print a big, or
      worse and infinite sequence. This should stop that.

      #+BEGIN_SRC emacs-lisp
        (setq cider-print-options '(("length" 1000)))
      #+END_SRC

      And seeing as we are limiting what we print, we should pretty
      print by default.

      #+BEGIN_SRC emacs-lisp
        (setq cider-repl-use-pretty-printing t)
      #+END_SRC

***** Customisations in CIDER

      Supress auto-display of the REPL buffer in separate window and
      make 'C-c C-z' switch to the CIDER REPL in the current window

      #+BEGIN_SRC emacs-lisp
        (setq cider-repl-pop-to-buffer-on-connect nil)
        (setq cider-repl-display-in-current-window t)
      #+END_SRC

***** Start figwheel-sidecar shortcuts

      From the Using Figwheel REPL within nREPL page.

      #+BEGIN_SRC emacs-lisp
        (defun cider-figwheel-repl ()
          (interactive)
          (save-some-buffers)
          (with-current-buffer (cider-current-repl-buffer)
            (goto-char (point-max))
            (insert
                "(require 'figwheel-sidecar.repl-api)
                 (do (figwheel-sidecar.repl-api/start-figwheel!) nil) ; idempotent
                     (figwheel-sidecar.repl-api/cljs-repl)")
            (cider-repl-return)))
          (add-hook 'cider-repl-mode-hook (lambda () (local-set-key (kbd "C-c C-f") 'cider-figwheel-repl)))
      #+END_SRC

***** A few repl tweaks

      I want paredit, rainbow delimiters and clojure-mode highlighting
      in my repl buffer.

      #+BEGIN_SRC emacs-lisp
        (add-hook 'cider-repl-mode-hook 'paredit-mode)
        (add-hook 'cider-repl-mode-hook 'rainbow-delimiters-mode)
        (add-hook 'cider-repl-mode-hook 'eldoc-mode)
      #+END_SRC

**** REBL repl

     #+BEGIN_SRC emacs-lisp
       ;; Similar to C-x C-e, but sends to REBL
       (defun rebl-eval-last-sexp ()
         (interactive)
         (let* ((bounds (cider-last-sexp 'bounds))
                (s (cider-last-sexp))
                (reblized (concat "(cognitect.rebl/inspect " s ")")))
           (cider-interactive-eval reblized nil bounds (cider--nrepl-print-request-map))))

       ;; Similar to C-M-x, but sends to REBL
       (defun rebl-eval-defun-at-point ()
         (interactive)
         (let* ((bounds (cider-defun-at-point 'bounds))
                (s (cider-defun-at-point))
                (reblized (concat "(cognitect.rebl/inspect " s ")")))
           (cider-interactive-eval reblized nil bounds (cider--nrepl-print-request-map))))

       ;; C-S-x send defun to rebl
       ;; C-x C-r send last sexp to rebl (Normally bound to "find-file-read-only"... Who actually uses that though?)
       (add-hook 'cider-mode-hook
                 (lambda ()
                   (local-set-key (kbd "C-S-x") #'rebl-eval-defun-at-point)
                   (local-set-key (kbd "C-x M-r") #'rebl-eval-last-sexp)))
     #+END_SRC

**** Alignment Changes

     There are very few bits of alignment that I would *ever* do
     differently from how emacs does it by default. Sometimes though
     the language moves faster than the modes that support it, or we
     have house rule (like let alignment).

     All formatting, beyond remaining consistent it a file, is
     fundamentally arbitrary and arguments about it descend into
     [[http://c2.com/cgi/wiki?BikeShed][bikeshedding]] very quickly. Here are our rules

***** align let forms

      Pretty alignment of let, when-let, if-let, binding, loop,
      with-open, literal hashes {}, defroute, cond, and condp
      (except :>> subforms). This is partly to keep things formatted
      the same way as Neale Swinnerton.

      #+BEGIN_SRC emacs-lisp
;;        (maybe-install-and-require 'align-cljlet)
      #+END_SRC

***** Indentation Override

      At the moment, indenting go loops like defn's is the only extra
      bit of overriding we do.

      #+BEGIN_SRC emacs-lisp
;;        (put-clojure-indent 'go-loop 'defun)
      #+END_SRC

**** clj-refactor

     Lots of cool little time savers in here.

     #+BEGIN_SRC emacs-lisp
       (maybe-install-and-require 'clj-refactor)
       (defun my-clojure-mode-hook ()
         (clj-refactor-mode 1)
         (yas-minor-mode 1) ; for adding require/use/import statements
         (cljr-add-keybindings-with-prefix "C-c RET")
         (setq cljr-favor-prefix-notation nil)
         (setq cljr-add-ns-to-blank-clj-files t))

         (add-hook
           'clojure-mode-hook #'my-clojure-mode-hook)
     #+END_SRC

**** clojurescript

     Get those cljs files building automatically and get the errors
     popping up in your emacs.

     #+BEGIN_SRC emacs-lisp
       (maybe-install-and-require 'cljsbuild-mode)
     #+END_SRC

**** helm and clojure

     Kris Jenkins has a great helm-clojure-headlines that I'd like to
     bind to s-h when in clojure-mode.

     #+BEGIN_SRC emacs-lisp
       (defun helm-clojure-headlines ()
         "Display headlines for the current Clojure file."
         (interactive)
         (helm-mode t)
         (helm :sources '(((name . "Clojure Headlines")
                           (volatile)
                           (headline "^[;(]")))))

       (add-hook 'clojure-mode-hook
                 (lambda () (local-set-key (kbd "s-h") 'helm-clojure-headlines)))
     #+END_SRC

**** Clojure Cheat Sheet

     It was this helm addon from Kris Jenkins that made me start to
     look at helm. And having the clojure cheat sheet to hand is
     useful.

     I like binding cheatsheets to s-f9.
     cheatsheet is installed as part of CIDER 17 now

     #+BEGIN_SRC emacs-lisp
       (add-hook 'clojure-mode-hook
         (lambda () (local-set-key [s-f9] 'clojure-cheatsheet)))
     #+END_SRC

**** Squiggly clojure

     Saw this mentioned in Bat's CIDER manual so thought I'd give it a
     shot

     #+BEGIN_SRC emacs-lisp
       (maybe-install-and-require 'flycheck-clojure)
       (maybe-install-and-require 'flycheck-pos-tip)
       ;; (eval-after-load 'flycheck '(flycheck-clojure-setup))
       ;; (add-hook 'after-init-hook #'global-flycheck-mode)
       ;; (with-eval-after-load 'flycheck
       ;;    (setq flycheck-display-errors-function #'flycheck-pos-tip-error-messages)
       ;;    (flycheck-pos-tip-mode 1))
     #+END_SRC

**** Expectations support

     Expectations mode is broken for cider 0.8.0 and no one uses it so
     I highjacked this from Sean Corfield.

     #+BEGIN_SRC emacs-lisp
       ;; run expectations
       (defun run-expectations ()
         (interactive)
         (cider-repl-set-ns (with-current-buffer (current-buffer) (cider-current-ns)))
         (cider-insert-in-repl "(expectations/run-tests [*ns*])" t))
       (global-set-key (kbd "C-c C-/") 'run-expectations)
     #+END_SRC


**** Joker linting using flycheck-joker

     Make sure you have the joker executable on your path somewhere.

     #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'flycheck-joker)
     #+END_SRC

**** clj-kondo linting

     Make sure you have the clj-kondo executable on your path.

     #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'flycheck-clj-kondo)
      (dolist (checker '(clj-kondo-clj clj-kondo-cljs clj-kondo-cljc clj-kondo-edn))
              (setq flycheck-checkers (cons checker (delq checker flycheck-checkers))))
      (dolist (checkers '((clj-kondo-clj . clojure-joker)
                          (clj-kondo-cljs . clojurescript-joker)
                          (clj-kondo-cljc . clojure-joker)
                          (clj-kondo-edn . edn-joker)))
              (flycheck-add-next-checker (car checkers) (cons 'error (cdr checkers))))
     #+END_SRC

**** clojure-lsp

     Trying clojure-lsp to see what static analysis can give me on top
     of CIDER.

     #+BEGIN_SRC emacs-lisp
      (use-package lsp-mode
        :ensure t
        :hook ((clojure-mode . lsp)
               (clojurec-mode . lsp)
               (clojurescript-mode . lsp))
        :config
        ;; add paths to your local installation of project mgmt tools, like lein
        (setenv "PATH" (concat
                         "/usr/local/bin" path-separator
                         (getenv "PATH")))
        (dolist (m '(clojure-mode
                     clojurec-mode
                     clojurescript-mode
                     clojurex-mode))
           (add-to-list 'lsp-language-id-configuration `(,m . "clojure")))
        (setq lsp-clojure-server-command '("bash" "-c" "clojure-lsp"))) ;; Optional: In case `clojure-lsp` is not in your PATH

        (use-package lsp-ui
          :ensure t
          :commands lsp-ui-mode)

        (use-package company-lsp
          :ensure t
          :commands company-lsp)
      (setq gc-cons-threshold (* 100 1024 1024)
            read-process-output-max (* 1024 1024)
            treemacs-space-between-root-nodes nil
            lsp-lens-enable t
            lsp-ui-doc-enable nil
            lsp-signature-auto-activate nil
            lsp-enable-indentation nil ; set to nil to use cider indentation instead of lsp
            lsp-enable-completion-at-point nil ; set to nil to use cider completion instead of lsp
            )
     #+END_SRC
** python

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'python)
     (maybe-install-and-require 'elpy)
     (add-hook 'python-mode-hook 'my-paredit-nonlisp)
     (setq python-shell-interpreter "/home/chris/anaconda3/bin/ipython"
           python-shell-interpreter-args "-i --simple-prompt")
     (elpy-enable)
   #+END_SRC



** javascript

*** js2 mode

    According to [[http://twitter.com/sw1nn][Neale Swinnerton]] js2-mode is the way to go.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'js2-mode)
      (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
      ;; Better imenu
      (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
      (setq js2-basic-offset 2)
    #+END_SRC

    And we can hook it in to run node.js shell scripts as well.

    #+BEGIN_SRC emacs-lisp
      (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
    #+END_SRC


*** js2 refactor

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'js2-refactor)
      (defun my-js2-mode-hook ()
       (let ((oldmap (cdr (assoc 'paredit-mode minor-mode-map-alist)))
             (newmap (make-sparse-keymap)))
        (set-keymap-parent newmap oldmap)
        (define-key newmap (kbd "C-k") nil)
        (make-local-variable 'minor-mode-overriding-map-alist)
        (push `(paredit-mode . ,newmap) minor-mode-overriding-map-alist))
      )
      (add-hook 'js2-mode-hook 'my-js2-mode-hook)
      (add-hook 'js2-mode-hook #'js2-refactor-mode)
      (add-hook 'js2-mode-hook 'my-paredit-nonlisp)
      (js2r-add-keybindings-with-prefix "C-c C-m")
      (define-key js2-mode-map (kbd "C-k") #'js2r-kill)
    #+END_SRC
*** xref js2

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'xref-js2)
      ;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
      ;; unbind it.
      (define-key js-mode-map (kbd "M-.") nil)
      (define-key paredit-mode-map (kbd "M-?") nil)
      (add-hook 'js2-mode-hook (lambda ()
       (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
    #+END_SRC

*** company-tern

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'company-tern)
      (add-to-list 'company-backends 'company-tern)
      (add-hook 'js2-mode-hook
       (lambda ()
         (tern-mode)
         (company-mode)))
      ;; Disable completion keybindings, as we use xref-js2 instead
      (define-key tern-mode-keymap (kbd "M-.") nil)
      (define-key tern-mode-keymap (kbd "M-,") nil)
    #+END_SRC

*** tern project dialog

    #+BEGIN_SRC emacs-lisp
     (require 'tern-project-dialog)
    #+END_SRC

*** prettier

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'prettier-js)
      ;; (add-hook 'js2-mode-hook 'prettier-js-mode)
      ;; (add-hook 'web-mode-hook 'prettier-js-mode)
      ;; (setq prettier-js-args '(
      ;;     "--trailing-comma" "all"
      ;;     "--bracket-spacing" "false"
      ;;     "--jsx-bracket-same-line" "true"
      ;;  ))
    #+END_SRC

*** js-format

    Try js-format instead of prettier as prettier is annoying me atm.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'js-format)
      (defun my-statement-format ()
        (interactive
          (progn
            (js-format-mark-statement t)
            (js-format-region (region-beginning) (region-end))
            (keyboard-quit))))
      (add-hook 'js2-mode-hook (lambda ()
        (define-key paredit-mode-map (kbd "M-q") nil)
        (define-key js2-mode-map (kbd "M-q") 'my-statement-format)))
    #+END_SRC

*** rjsx-mode

    Add rjsx mode.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'rjsx-mode)
    #+END_SRC

*** indium

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'indium)
     (setq indium-chrome-executable "google-chrome")
     (add-hook 'js-mode-hook #'indium-interaction-mode)
    #+END_SRC

*** pug mode - for pug templating

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'pug-mode)
      (add-hook 'pug-mode-hook 'my-paredit-nonlisp)
    #+END_SRC


** typescript


*** Typescript mode

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'typescript-mode)

      ;; make sure paredit doesn't add space before parens
      (add-hook 'typescript-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

*** Tide

    Try tide the typescript interactive development environment for
    Emacs.

    #+BEGIN_SRC emacs-lisp
        (maybe-install-and-require 'tide)
        (defun setup-tide-mode ()
          (interactive)
          (tide-setup)
          (flycheck-mode +1)
          (setq flycheck-check-syntax-automatically '(save mode-enabled))
          (eldoc-mode +1)
          (tide-hl-identifier-mode +1)
          ;; company is an optional dependency. You have to
          ;; install it separately via package-install
          ;; `M-x package-install [ret] company`
          (company-mode +1))

      ;; aligns annotation to the right hand side
      (setq company-tooltip-align-annotations t)

      ;; formats the buffer before saving
      (add-hook 'before-save-hook 'tide-format-before-save)

      (add-hook 'typescript-mode-hook #'setup-tide-mode)

      ;; format
      (setq tide-format-options '(:insertSpaceAfterFunctionKeywordForAnonymousFunctions t :placeOpenBraceOnNewLineForFunctions nil))
    #+END_SRC

** elasticsearch

   Who knew you could poke elasticsearch from inside emacs. :-D

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'es-mode)
     (add-to-list 'auto-mode-alist '("\\.es$" . es-mode))
   #+END_SRC

** pastebins

   gist, pastebin, refheap. All good ways of sharing snippets of code
   with people on irc or similar.

*** gist

    As you probably already have a github account, having gist as a
    way of sharing code snippets is a good idea.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'gist)
    #+END_SRC

*** refheap

    I like [[http://refheap.com][refheap]] and Anthony Grimes seems like a nice guy. And it
    is built in clojure.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'refheap)
    #+END_SRC

** restclient

   Added in rest client to allow for manual testing of restful client.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'restclient)
   #+END_SRC

** HTTP org babel

   #+BEGIN_SRC emacs-lisp
   (maybe-install-and-require 'ob-http)
   #+END_SRC

** Haskell

*** Haskell mode

    Require Haskell mode

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'haskell-mode)
    #+END_SRC

*** hindent

    Add indentation for Haskell

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'hindent)
      ;; (add-hook 'haskell-mode-hook #'hindent-mode)
    #+END_SRC

*** intero - for Haskella

    Going to try intero with Haskell projects.

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'intero)
      ;; (add-hook 'haskell-mode-hook #'intero-mode)
    #+END_SRC

*** stylish-haskell

    #+BEGIN_SRC emacs-lisp
      ;; (custom-set-variables
      ;;  '(haskell-stylish-on-save t))
    #+END_SRC

*** Interactive features

    #+BEGIN_SRC emacs-lisp
      ;; (add-hook `haskell-mode-hook `interactive-haskell-mode)
      ;; (custom-set-variables
      ;;  '(haskell-process-suggest-remove-import-lines t)
      ;;  '(haskell-process-auto-import-loaded-modules t)
      ;;  '(haskell-process-log t)
      ;;  '(haskell-process-type 'stack-ghci)
      ;;  '(haskell-process-type 'chosen-process-type))
      ;; (eval-after-load 'haskell-mode '(progn
      ;;   (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
      ;;   (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
      ;;   (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
      ;;   (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
      ;;   (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
      ;;   (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
      ;; (eval-after-load 'haskell-cabal '(progn
      ;;                                    (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
      ;;                                    (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
      ;;                                    (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
      ;;                                    (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal)))
    #+END_SRC

** Scala

# *** ensime
#
#     I am going to try ensime for Scala.
#
#     #+BEGIN_SRC emacs-lisp
#       (maybe-install-and-require 'ensime)
#       (add-hook 'scala-mode-hook 'ensime-mode)
#       (add-hook 'scala-mode-hook
#         (local-set-key (kbd "M-;") 'comment-or-uncomment-region))
#     #+END_SRC

*** Scala mode

    #+BEGIN_SRC emacs-lisp
     (when (not (package-installed-p 'scala-mode))
       (package-install 'scala-mode))
     (use-package scala-mode
       :mode "\\.s\\(cala\\|bt\\)$")
     (setq use-package-always-defer t
       use-package-always-ensure t
       backup-directory-alist `((".*" . ,temporary-file-directory))
       auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))

     ;; Enable scala-mode for highlighting, indentation and motion commands
     (use-package scala-mode
       :interpreter
       ("scala" . scala-mode))
    #+END_SRC

*** sbt mode

    #+BEGIN_SRC emacs-lisp
     (when (not (package-installed-p 'sbt-mode))
      (package-install 'sbt-mode))

     (use-package sbt-mode
        :commands sbt-start sbt-command
        :config
        ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
        ;; allows using SPACE when in the minibuffer
        (substitute-key-definition
         'minibuffer-complete-word
         'self-insert-command
         minibuffer-local-completion-map)
         ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
         (setq sbt:program-options '("-Dsbt.supershell=false")))

     (add-hook 'scala-mode-hook
        ;;(local-set-key (kbd "C-c C-t") 'sbt-do-test)
        (local-set-key (kbd "C-c C-s") 'sbt-hydra))
    #+END_SRC

*** Metals for lsp

    Add metals backend for lsp-mode

    #+BEGIN_SRC emacs-lisp
     ;; Add metals backend for lsp-mode
     (use-package lsp-metals
       :config (setq lsp-metals-treeview-show-when-views-received t))
    #+END_SRC

*** Scala newlines in comments

    #+BEGIN_SRC emacs-lisp
    (defun scala-mode-newline-comments ()
        "Custom newline appropriate for `scala-mode'."
        ;; shouldn't this be in a post-insert hook?
          (interactive)
          (newline-and-indent)
          (scala-indent:insert-asterisk-on-multiline-comment))

      ;; (define-key scala-mode-map (kbd "RET") 'scala-mode-newline-comments)
    #+END_SRC

*** Comment regions

    #+BEGIN_SRC emacs-lisp
     (defun scala-comment-region ()
          (setq comment-start "/* "
                comment-end " */"
                comment-style 'multi-line
                comment-empty-lines t))
      (add-hook 'scala-mode-hook 'scala-comment-region)
    #+END_SRC

*** Fix paredit for scala

    Don't want spaces between symbols and parens for Scala

    #+BEGIN_SRC emacs-lisp
     (add-hook 'scala-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

*** Open and scale windows for use with Scala and Java

    I like having my ensime sbt and scala console buffers at the
    bottom of the frame a bit like something like Intellij or Eclipse.

    #+BEGIN_SRC emacs-lisp
       (defun ide-panes ()
         (interactive)
         (delete-other-windows)

         (progn
               ;; create our 2 columns
               (window-number-select 1)
               (split-window-right)

                ;; split column vertically
               (split-window-below)
               (window-number-select 3)
               (split-window-below)

               ;; expand top windows
               (enlarge-window 20)
               (window-number-select 1)
               (enlarge-window 20)))

        (global-set-key [M-f12] 'ide-panes)
    #+END_SRC

    #+RESULTS:
    : ide-panes



** Java
*** Fix paredit for Java

    Don't want spaces between symbols and parens for Java

    #+BEGIN_SRC emacs-lisp
     (add-hook 'java-mode-hook 'my-paredit-nonlisp)
    #+END_SRC
*** Fix indents for Java

    #+BEGIN_SRC emacs-lisp
      (add-hook 'java-mode-hook (lambda ()
                                  (c-set-offset 'arglist-intro '++)
                                  (c-set-offset 'arglist-close 'c-lineup-arglist)
                                  (c-set-offset 'statement-cont '++)
                                  (c-set-offset 'case-label '+)
                                  (setq c-basic-offset 4
                                        tab-width 4
                                        indent-tabs-mode nil)))
    #+END_SRC

*** Jdee

    Add in JDEE for Java.

    #+BEGIN_SRC emacs-lisp
;;      (maybe-install-and-require 'jdee)
;;      (setq jdee-server-dir "/home/chris/jdeejar")
    #+END_SRC

*** Eclim

    Try out eclim mode for Java for a bit.

    #+BEGIN_SRC emacs-lisp
            ;; (maybe-install-and-require 'eclim)
            ;; (setq eclim-eclipse-dir '("~/eclipse"))
            ;; (setq eclimd-executable "~/eclipse/eclimd")
            ;; (setq eclim-executable "~/eclipse/eclim")
            ;; (setq eclimd-autostart t)
            ;; (defun my-java-mode-hook ()
            ;;   (eclim-mode t)
            ;;   (local-set-key (kbd "c-c c-e c-r") 'eclim-run-class))
            ;; (add-hook 'java-mode-hook 'my-java-mode-hook)
      ;;      (maybe-install-and-require 'company-emacs-eclim)
      ;;      (company-emacs-eclim-setup)
    #+END_SRC

*** Meghanada

    Add meghanada mode (no idea why this is not in here!)

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'meghanada)
      ;; (add-hook 'java-mode-hook
      ;;    (lambda ()
      ;;      (meghanada-mode t)
      ;;      (setq c-basic-offset 4)))
    #+END_SRC

*** LSP Java/Scala

    Java and Scala support for lsp mode using the Eclipse JDT Language Server.

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'lsp-mode)
      (setq lsp-keymap-prefix "M-s-l")
      (define-key lsp-mode-map (kbd "M-s-l") lsp-command-map)
      (setq gc-cons-threshold 1000000)
      (setq read-process-output-max (* 1024 1024 2))
;;      (setq lsp-completion-provider :capf)
      (setq lsp-idle-delay 0.5)
      (use-package lsp-mode
          :hook ((java-mode . lsp)
                 (scala-mode . lsp)
                 ;; if you want which-key integration
                 (lsp-mode . lsp-enable-which-key-integration)
                 (lsp-mode . flycheck-mode)
                 (lsp-mode . lsp-lens-mode)
                 )
          :config (setq lsp-prefer-flymake nil)
                  (setq lsp-keep-workspace-alive nil)
          :commands lsp)
      (maybe-install-and-require 'lsp-ui)
      (use-package lsp-java)
      (add-hook 'java-mode 'lsp-mode)

      ;; Use eclipse 2.1 formatting
      (setq lsp-java-format-settings-url "file:///home/chris/eclipse/myeclipse21formatter.xml")
      (setq lsp-java-format-settings-profile "myeclipse21formatter")

      ;; Don't watch files
      (setq lsp-enable-file-watchers nil)

      ;; Add metals backend for lsp-mode scala
      (maybe-install-and-require 'lsp-metals)

      ;; optionally
      (use-package lsp-ui :commands lsp-ui-mode)
      ;; if you are helm user
      (use-package helm-lsp :commands helm-lsp-workspace-symbol)
      ;; if you are ivy user
      (use-package lsp-ivy :commands lsp-ivy-workspace-symbol)
      (use-package lsp-treemacs
        :commands lsp-treemacs-errors-list
        :config
        (lsp-metals-treeview-mode t)
        (setq lsp-metals-treeview-show-when-views-received t)
      )

      ;; add lombok to classpath for lsp
      (setq path-to-lombok "/home/chris/.m2/repository/org/projectlombok/lombok/1.18.10/lombok-1.18.10.jar")
      (setq lsp-java-vmargs
             `("-noverify"
               "-Xmx1G"
;;               "-XX:+UseG1GC"
;;               "-XX:+UseStringDeduplication"
               ,(concat "-javaagent:" path-to-lombok)
               ,(concat "-Xbootclasspath/a:" path-to-lombok)))
    #+END_SRC

*** DAP mode

    #+BEGIN_SRC emacs-lisp
      (use-package posframe
      ;; Posframe is a pop-up tool that must be manually installed for dap-mode
        )
      (when (not (package-installed-p dap-mode))
        (package-install 'dap-mode))
      (use-package dap-mode
        :after lsp-mode
        :hook ((lsp-mode . dap-mode)
               (lsp-mode . dap-ui-mode))
        :config (dap-auto-configure-mode))
      ;; (use-package dap-java :ensure nil)
      (require 'dap-java)
      (define-key dap-mode-map (kbd "M-s-l t t") 'dap-java-run-test-method)
      (define-key dap-mode-map (kbd "M-s-l t c") 'dap-java-run-test-class)
      (define-key dap-mode-map (kbd "M-s-l t d") 'dap-java-debug-test-method)
    #+END_SRC
** Kotlin

*** Kotlin mode

    Install Kotlin mode.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'kotlin-mode)
    #+END_SRC

*** Fix paredit for Kotlin

    Don't want spaces between symbols and parens for Kotlin.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'kotlin-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

** GraphQL

*** Graphql mode

    Add graphql mode.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'graphql-mode)
     (add-to-list 'auto-mode-alist '("\\.graphqls\\'" . graphql-mode))
    #+END_SRC

** Gradle

   Install and require gradle mode

   #+BEGIN_SRC emacs-lisp
   (maybe-install-and-require 'gradle-mode)
   ;; (add-to-list 'auto-mode-alist '("\\.gradle\\" . gradle-mode))
   #+END_SRC

** Groovy

   Install and require groovy mode.

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'groovy-mode)
    (add-hook 'groovy-mode 'my-paredit-nonlisp)
    (add-to-list 'auto-mode-alist
             (cons "\\.gradle\\'" 'groovy-mode))
   #+END_SRC

** Docker

*** Dockerfile mode

    Install and require Dockerfile mode to provide syntax highlighting
    for Dockerfiles.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'dockerfile-mode)
    #+END_SRC

*** Docker mode

    Install and require docker mode for running docker in emacs.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'docker)
    #+END_SRC

** Elixir

*** Elixir mode

    Install Elixir mode.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'elixir-mode)
    #+END_SRC

*** Alchemist

    Install Alchemist for Elixir tooling.

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'alchemist)
    #+END_SRC

*** Fix paredit for Elixir

    Don't want spaces between symbols and parens for Elixir

    #+BEGIN_SRC emacs-lisp
     (add-hook 'elixir-mode 'my-paredit-nonlisp)
    #+END_SRC
** Kubernetes

   Try out k8s mode

   #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'kubernetes)
   #+END_SRC
** Ruby

*** Ruby mode

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'ruby-mode)
     (add-hook 'ruby-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

*** Other file types that contain Ruby

    Some other file extensions contain Ruby.

    #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist
             '("\\.\\(?:cap\\|gemspec\\|irbrc\\|gemrc\\|rake\\|rb\\|ru\\|thor\\)\\'" . ruby-mode))
     (add-to-list 'auto-mode-alist
             '("\\(?:Brewfile\\|Capfile\\|Gemfile\\(?:\\.[a-zA-Z0-9._-]+\\)?\\|[rR]akefile\\)\\'" . ruby-mode))
    #+END_SRC

*** Ruby electric

    More ruby support via Ruby electric..

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'ruby-electric)
    #+END_SRC

*** RVM as default package manager

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'rvm)
     (rvm-use-default)
    #+END_SRC

*** Seeing is believing for ruby buffer interaction

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'seeing-is-believing)
     (add-hook 'ruby-hook 'seeing-is-believing)
    #+END_SRC

*** IRB from emacs

    Use inf-ruby...

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'inf-ruby)
     (autoload 'inf-ruby-minor-mode "inf-ruby" "Run an inferior Ruby process" t)
     (add-hook 'ruby-mode 'inf-ruby-minor-mode)
     (add-hook 'inf-ruby-minor-mode
       (lambda ()
         (local-set-key (kbd "C-c C-e") 'ruby-send-line)
         (local-set-key (kbd "C-c C-k") 'ruby-send-buffer-and-go)))
    #+END_SRC

*** Ruby TDD from emacs

    Use ruby test mode

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'ruby-test-mode)
     (add-hook 'ruby-mode 'ruby-test-mode)
     (add-hook 'compilation-finish-functions
          (lambda (buf strg)
            (switch-to-buffer-other-window "*compilation*")
            (read-only-mode)
            (goto-char (point-max))
            (local-set-key (kbd "q")
                           (lambda () (interactive) (quit-restore-window)))))
    #+END_SRC

*** Use company mode for Ruby inf buffers

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'company-inf-ruby)
     (eval-after-load 'company
      '(add-to-list 'company-backends 'company-inf-ruby))
    #+END_SRC

*** Use Robe for Ruby code assistance

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'robe)
     (add-hook 'ruby-mode-hook 'robe-mode)
    #+END_SRC

** Terraform

*** Terraform mode

    Add terraform mode

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'terraform-mode)
    #+END_SRC

*** Company backend for terraform

    Add autocomplete using company for terraform

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'company-terraform)
     (company-terraform-init)
    #+END_SRC

** Rust

*** Rust mode

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'rust-mode)
     (add-hook 'rust-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

*** Flymake

    #+BEGIN_SRC emacs-lisp
      ;; (maybe-install-and-require 'flymake-rust)
      ;; (with-eval-after-load 'rust-mode
      ;;   (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
    #+END_SRC

*** Racer

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'racer)
     (add-hook 'rust-mode-hook 'racer-mode)
    #+END_SRC

*** Cargo

    #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'cargo)
    #+END_SRC


** Golang

**

*** Go-mode

    Add go-mode

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'go-mode)
      (add-hook 'go-mode-hook 'my-paredit-nonlisp)
    #+END_SRC

*** Godoc

    Add godoc

    #+BEGIN_SRC emacs-lisp
      (setenv "GOPATH" "/Users/tleyden/Development/gocode")
    #+END_SRC

*** Gofmt on save

    Run gofmt on save.

    #+BEGIN_SRC emacs-lisp
     (add-to-list 'exec-path "/Users/tleyden/Development/gocode/bin")
    #+END_SRC

*** Godef bindings

    Set up key bindings for godef.

    #+BEGIN_SRC emacs-lisp
     (defun my-go-mode-hook ()
       ; Call Gofmt before saving
       (add-hook 'before-save-hook 'gofmt-before-save)
       ; Godef jump key binding
       (local-set-key (kbd "M-.") 'godef-jump)
       (local-set-key (kbd "M-*") 'pop-tag-mark))

     (add-hook 'go-mode-hook 'my-go-mode-hook)
    #+END_SRC

*** Company completion for go

    Set up company mode for Golang

    #+BEGIN_SRC emacs-lisp
      (maybe-install-and-require 'company-go)
      (add-hook 'go-mode-hook (lambda ()
                                (set (make-local-variable 'company-backends) '(company-go))
                                (company-mode)))
    #+END_SRC

** Log mode

   #+begin_src emacs-lsp
   (maybe-install-and-require 'logview)
   #+end_src


** Graphql


*** Graphql mode

    #+BEGIN_SRC emacs-lisp
    (maybe-install-and-require 'graphql-mode)
    (maybe-install-and-require 'ob-graphql)
    #+END_SRC

* Data Modes

  Some things aren't really text and aren't really source code
  files. We'll deal with them below.

** csv-mode

   Lots of great things for sorting, unsorting, munging and editing
   csv files.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'csv-mode)
   #+END_SRC

** jq mode

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'jq-mode)
   #+END_SRC

* Multimedia

** emms to play music

   I've used emms before. I like the way you just need an underlying
   media player and emacs is just a thin shell over that, with some
   files to help with play lists. We're using mpg321 from homebrew on
   a mac to play the files.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'emms)
     (require 'emms-setup)
;;     (require 'emms-player-simple)
     (require 'emms-source-file)
     (require 'emms-source-playlist)
     (emms-all)
     (emms-default-players)
     (setq emms-source-file-default-directory (concat (getenv "HOME") "/Music/"))
   #+END_SRC

*** emms keybindings

    f7-f9 are the previous, play/pause and next keys. It is quite
    handy having them bound to do that for emms.

    And a control-meta to start everything off.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "<f7>") 'emms-previous)

      (global-set-key (kbd "<f8>") 'emms-pause)
      (global-set-key (kbd "C-<f8>") 'emms-play-playlist)
      (global-set-key (kbd "M-<f8>") 'emms-play-dired)
      (global-set-key (kbd "s-<f8>") 'emms-stop)

      (global-set-key (kbd "<f9>") 'emms-next)
    #+END_SRC

*** Turn off emms-mode-line

    There really is enough in that modeline already. We don't need to
    add more.

    #+BEGIN_SRC emacs-lisp
;;      (require 'emms-mode-line)
;;      (emms-mode-line 0)
    #+END_SRC

** Image+ mode

   Add image+ mode to support image zooming

   #+BEGIN_SRC emacs-lisp
   (maybe-install-and-require 'image+)
   (eval-after-load 'image '(require 'image+))
   #+END_SRC

** PDF tools

   Use pdf tools for pdf's

   #+BEGIN_SRC emacs-lisp
     (pdf-tools-install)
     (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
   #+END_SRC
* Notification Systems

** The great eye of Sauron

   With all these various systems going on we probably want to be able
   to have a log of what has happened so we can step through
   it. Sauron should help us with this. I'm sure nothing can go
   wrong. I feel so powerful that it must be right.

   #+BEGIN_SRC emacs-lisp
     (maybe-install-and-require 'sauron)
   #+END_SRC

*** dbus hacks

    If we want new mail notifications with sauron as described [[http://www.djcbsoftware.nl/code/mu/mu4e/Getting-new-mail-notifications-with-Sauron.html][here]],
    then we apparently need to turn the dbus cookie on.

    #+BEGIN_SRC emacs-lisp
      (setq sauron-dbus-cookie t)
    #+END_SRC

*** Mute twitter

    I don't really want to know when I get new tweets. I might want to
    know when I get @replies and DMs though.

    #+BEGIN_SRC emacs-lisp
;;      (setq sauron-prio-twittering-new-tweets 4)
    #+END_SRC

* Local Config

** custom.el

   custom.el is great for configuring things through that "gui" in
   emacs, but it is a real pain when it drops junk in your [[../init.el][init.el]] and
   messes up your pretty config and git history and is stuff that you
   don't want to leak out on to github. You can change the location of
   this file though and I like to do this.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "local/custom.el"))
     (load-if-exists custom-file)
   #+END_SRC

* Utilities and General Keybindings

** join-line

   A quick way of getting lines back together.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "s-<return>") 'join-line)
   #+END_SRC

** Org mind map

   Try out mind mapping in emacs.

   #+BEGIN_SRC emacs-lisp
;;    (maybe-install-and-require 'org-mind-map)
   #+END_SRC

** Ox Freemind

   Try out Org mode to FreeMind mapping

   #+BEGIN_SRC emacs-lisp
;;     (require 'ox-freemind)
   #+END_SRC
* Misc

  Miscellaneous stuff.

** clojure cookbook next recipe

   This is a fn to 'turn the page' to the next recipe in the Clojure
   Cookbook

   #+BEGIN_SRC emacs-lisp
     (defun increment-clojure-cookbook ()
       "When reading the Clojure cookbook, find the next section, and
       close the buffer. If the next section is a sub-directory or in
       the next chapter, open Dired so you can find it manually."
       (interactive)
       (let* ((cur (buffer-name))
              (split-cur (split-string cur "[-_]"))
              (chap (car split-cur))
              (rec (car (cdr split-cur)))
              (rec-num (string-to-number rec))
              (next-rec-num (1+ rec-num))
              (next-rec-s (number-to-string next-rec-num))
              (next-rec (if (< next-rec-num 10)
                            (concat "0" next-rec-s)
                          next-rec-s))
              (target (file-name-completion (concat chap "-" next-rec) "")))
         (progn
           (if (equal target nil)
               (dired (file-name-directory (buffer-file-name)))
             (find-file target))
           (kill-buffer cur))))
      (define-key adoc-mode-map (kbd "C->") 'increment-clojure-cookbook)
   #+END_SRC

** Typing tutor

   #+BEGIN_SRC emacs-lisp
;;    (maybe-install-and-require 'speed-type)
   #+END_SRC

* Finishing

** General Cleanup

   This is a bit pathetic, but sometimes things get set by various
   modes above and to be honest, I'm just too lazy at the moment to
   figure out which ones. So, we'll do some final bits of clean up
   down here and maybe some day, I'll get around to it.

*** Random Default on Minor Modes

    With newer version of emacs new minor modes get turned on by
    default and clutter up my mode line. I'd like to turn them off.

** passwords and encrypted things

   It is good to store your passwords and things in an encrypted
   file. I call mine mellon, because you can only read it if you are
   my friend and have the passphrase.

   This does mean that every time you use it you have to give the
   passphrase, but it does mean that you can keep all your passwords
   for things like erc and stuff in a file reasonably safely (though
   it will be in memory when emacs is running, so it isn't completely
   secure).

   #+BEGIN_SRC emacs-lisp
     (load-if-exists (concat user-emacs-directory "local/mellon.el.gpg"))
   #+END_SRC

** emacs-server

   Emacs startup time isn't nearly as much of a problem as it used to
   be. I'm also pretty patient as I've been working with JVM startup
   times over the years.

   However, it is still nice to be able to attach to a running Emacs
   process when we want to. To that end, let's start up an
   emacs-server.

   #+BEGIN_SRC emacs-lisp
     ;; (server-start)
   #+END_SRC

** Finis

   I should really come up with better exhortations than this. The
   stuff that Sam Aaron has in emacs-live I actually find quite
   inspirational. cider.el has similar, though more specifically
   clojurian things to say that I quite like as well.

   However, I've always expected that any sufficiently advanced lisp
   system has probably gained sentience. I think Emacs probably
   qualifies for that.

   Therefore, let's sign off as so...

   #+BEGIN_SRC emacs-lisp
     (message "TTFN.")
   #+END_SRC
